<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>强化学习笔记</title>
      <link href="/2025/03/19/RL_studynote/"/>
      <url>/2025/03/19/RL_studynote/</url>
      
        <content type="html"><![CDATA[<h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><p><img src="D:/BLOG/source/_posts/RL_studynote/p1.png" alt="学习顺序"></p><p>强化学习的总体目标：寻找最优策略。</p><h2 id="关键名词"><a href="#关键名词" class="headerlink" title="关键名词"></a>关键名词</h2><ul><li><p><strong>智能体（Agent）</strong></p></li><li><p><strong>状态（State）</strong>：智能体相对于环境的状态 $s∈S$</p></li><li><p><strong>状态空间（State space）</strong>：把所有状态放在一起，所有状态的集合（set）$S={s_1,s_2,…,s_n}$</p></li><li><p><strong>动作（Action）</strong>：对于每个状态，所可能采取的行动 $a∈A(s)$</p></li><li><p><strong>动作空间（Action space）</strong>：某状态下所可能采取的所有动作的集合（动作依赖于状态）$A(s)={a_1,a_2,…,a_m}$</p></li><li><p><strong>状态转移（State transition）</strong>：通过采取一个动作，智能体从一个状态进入另一个</p></li><li><p><strong>状态转移概率（State transition probability）</strong>：用条件概率描述状态转移 $P(s′∣s,a)$</p></li><li><p><strong>策略（Policy）</strong>：策略告诉智能体在某一状态下应采取什么行动</p><p>在数学上，策略被定义为在给定状态 $s$ 时选择行动 $a$ 的概率，即 $π(a∣s)$。</p><p>策略 $π$ 需要满足以下条件：对于所有状态 $s∈S$，所有可能行动 $a∈A(s)$ 的概率之和等于 1：</p></li></ul><script type="math/tex; mode=display">\sum_{a∈A(s)}π(a∣s)=1</script><ul><li><p><strong>回报（Reward）</strong>：回报 $R(s,a)$ 是智能体在状态 $s$ 下执行动作 $a$ 后获得的标量值。它可以是正数（奖励）或负数（惩罚）。</p></li><li><p><strong>轨迹（Trajectory）和收益（Return）</strong>：轨迹是一系列状态、动作和回报的序列，形式为 $(s_0,a_0,r_0,s_1,a_1,r_1,…,s_T)$。轨迹的收益 $G$ 是沿轨迹收集的所有回报的总和：</p><script type="math/tex; mode=display">G=\sum_{t=0}^{T−1}r_t</script></li><li><p><strong>折扣收益（Discounted Return）</strong>：在无限或长期的环境中，折扣收益用于优先考虑即时回报，而不是未来的回报。它通过折扣因子 $γ$（其中 $0≤γ≤1$）来计算：</p><script type="math/tex; mode=display">G=\sum_{∑t=0}^{∞}γ_tr_t</script><p>当 $\gamma=1$ 时，它就是标准的收益。折扣因子可使得无限序列的总和是有限的，并且模型能够捕捉到即时回报比未来回报更有价值这一概念。$\gamma$越接近1越远视（注重长期回报），$\gamma$越接近0越近视（注重及时回报）。</p></li><li><p><strong>Episode</strong>：一个有限的轨迹，通常在特定的终止状态处结束。</p></li><li><p><strong>马尔科夫决策过程（Markov decision process, MDP)</strong>：MDP 的目标是找到一个策略 $π$，使得从起始状态开始的预期折扣收益最大化。具有无记忆性（和之前的状态无关）。</p></li></ul><script type="math/tex; mode=display">π^∗=\mathrm{argmax_{\pi}}E_π[G∣s0]</script><p>其中 $E_π[G∣s0]$ 表示在策略 $π$ 下，从初始状态 $s_0$ 开始的预期折扣收益。</p><p>MDP 由以下组件定义：</p><ul><li>状态空间 $S$</li><li>动作空间 $A(s)$</li><li>状态转移概率 $P(s′∣s,a)$</li><li>回报函数 $R(s,a)$</li><li>折扣因子 $γ$</li></ul><hr><h2 id="贝尔曼公式"><a href="#贝尔曼公式" class="headerlink" title="贝尔曼公式"></a>贝尔曼公式</h2><h3 id="状态值函数（State-Value-Function）"><a href="#状态值函数（State-Value-Function）" class="headerlink" title="状态值函数（State Value Function）"></a>状态值函数（State Value Function）</h3><p><strong>定义</strong>：<br>在策略$\pi$下从状态$s$出发的<strong>预期折扣收益</strong>，其定义为：</p><script type="math/tex; mode=display">V^{\pi}(s) = \mathbb{E}_{\pi} \left[ G \mid s_0 = s \right] = \mathbb{E}_{\pi} \left[ \sum_{t=0}^{\infty} \gamma^t r_t \bigg| s_0 = s \right]</script><p>其中：</p><ul><li>$\mathbb{E}_{\pi}[\cdot]$表示在策略$\pi $下的期望，覆盖动作选择和状态转移的随机性。</li><li>$G = \sum_{t=0}^{\infty} \gamma^t r_t$是折扣收益，$\gamma \in [0,1)$是折扣因子，确保无穷级数收敛。</li><li>$r<em>t = R(s_t, a_t)$是时刻$t$的即时回报，$a_t \sim \pi(\cdot \mid s_t)$，状态转移由$s</em>{t+1} \sim P(\cdot \mid s_t, a_t)$决定。</li></ul><h3 id="贝尔曼方程（Bellman-Equation）"><a href="#贝尔曼方程（Bellman-Equation）" class="headerlink" title="贝尔曼方程（Bellman Equation）"></a>贝尔曼方程（Bellman Equation）</h3><p>状态值函数满足递归关系：</p><script type="math/tex; mode=display">V^{\pi}(s) = \sum_{a \in A} \pi(a \mid s) \left[ R(s,a) + \gamma \sum_{s' \in S} P(s' \mid s,a) V^{\pi}(s') \right], \quad \forall s \in S</script><p><strong>含义</strong>：<br>当前状态的值等于即时回报的期望，加上未来状态的期望折扣值。</p><p><strong>矩阵形式</strong>：  </p><script type="math/tex; mode=display">\mathbf{V}^{\pi} = \mathbf{R}^{\pi} + \gamma \mathbf{P}^{\pi} \mathbf{V}^{\pi}</script><p>其闭式解为：</p><script type="math/tex; mode=display">\mathbf{V}^{\pi} = (I - \gamma \mathbf{P}^{\pi})^{-1} \mathbf{R}^{\pi}</script><p>当 $\gamma &lt; 1$ 时，矩阵$(I - \gamma \mathbf{P}^{\pi})$可逆。</p><h3 id="动作值函数（Action-Value-Function）"><a href="#动作值函数（Action-Value-Function）" class="headerlink" title="动作值函数（Action Value Function）"></a>动作值函数（Action Value Function）</h3><p><strong>定义</strong>：<br>动作值函数$Q^{\pi}(s,a)$表示从状态$s$执行动作$a$后，遵循策略$ \pi $的预期折扣收益：</p><script type="math/tex; mode=display">Q^{\pi}(s,a) = \mathbb{E}_{\pi} \left[ \sum_{t=0}^{\infty} \gamma^t r_t \bigg| s_0 = s, a_0 = a \right]</script><p><strong>与状态值函数的关系</strong>：<br>状态值函数可表示为动作值函数的期望：</p><script type="math/tex; mode=display">V^{\pi}(s) = \sum_{a \in A} \pi(a \mid s) Q^{\pi}(s,a)</script><p><strong>动作值的贝尔曼方程</strong>：<br>动作值函数同样满足递归关系：</p><script type="math/tex; mode=display">Q^{\pi}(s,a) = R(s,a) + \gamma \sum_{s' \in S} P(s' \mid s,a) V^{\pi}(s')</script><hr><h2 id="贝尔曼最优公式"><a href="#贝尔曼最优公式" class="headerlink" title="贝尔曼最优公式"></a>贝尔曼最优公式</h2><h3 id="最优策略与最优值函数"><a href="#最优策略与最优值函数" class="headerlink" title="最优策略与最优值函数"></a>最优策略与最优值函数</h3><p><strong>最优策略定义</strong>：<br>策略$\pi^*$是最优的，当且仅当对任意状态$s$，其满足：</p><script type="math/tex; mode=display">\pi^*(a \mid s) = \begin{cases} 1, & a = \arg\max_{a'} Q^{\pi^*}(s,a') \\0, & \text{其他}\end{cases}</script><p><strong>最优状态值函数</strong>：<br>最优值函数$V^*(s)$是所有策略中最大的状态值：</p><script type="math/tex; mode=display">V^*(s) = \max_{\pi} V^{\pi}(s)</script><p><strong>贝尔曼最优方程</strong>：<br>最优值函数满足：</p><script type="math/tex; mode=display">V^*(s) = \max_{a \in A} \left[ R(s,a) + \gamma \sum_{s' \in S} P(s' \mid s,a) V^*(s') \right], \quad \forall s \in S</script><p>对应动作值函数的最优方程为：</p><script type="math/tex; mode=display">Q^*(s,a) = R(s,a) + \gamma \sum_{s' \in S} P(s' \mid s,a) \max_{a'} Q^*(s',a')</script><p><strong>存在性与唯一性</strong></p><ol><li><strong>存在性</strong>：在有限马尔可夫决策过程MDP中，若$\gamma &lt; 1$，则存在唯一的最优值函数$V^<em>$和$Q^</em>$，以及至少一个确定性最优策略 $\pi^*$。</li><li><strong>唯一性</strong>：存在唯一最优解（最优策略不一定唯一）。放缩映射证明。</li><li><strong>收敛性</strong>：通过值迭代或策略迭代算法，可逐步逼近$V^<em>$ 和$\pi^</em>$（指数级收敛）。</li></ol><hr><h2 id="值迭代（Value-Iteration）"><a href="#值迭代（Value-Iteration）" class="headerlink" title="值迭代（Value Iteration）"></a>值迭代（Value Iteration）</h2><p><strong>基本思想</strong></p><p>通过<strong>直接迭代贝尔曼最优方程</strong>求解最优值函数，最终从最优值函数中提取最优策略。动态规划思想，通过同步备份（synchronous backup）更新所有状态的值。</p><p><strong>算法步骤</strong></p><script type="math/tex; mode=display">V_{k}(s)\to Q_{k}(s,a) \to \pi_{k+1}(a|s) \to V_{k+1}(s) \to \max_aQ_{k}(s,a)</script><ol><li><p><strong>初始化</strong>：<br>对所有状态$s \in S$，设置初始值$V_0(s) = 0$（或其他任意值）</p></li><li><p><strong>迭代更新</strong>：<br>重复以下更新直至收敛：</p><script type="math/tex; mode=display">V_{k+1}(s) = \max_{a \in A} \left[ R(s,a) + \gamma \sum_{s' \in S} P(s' \mid s,a) V_k(s') \right], \quad \forall s \in S</script><p>更新方式为<strong>同步备份</strong>（先计算所有新值，再整体替换旧值）</p></li><li><p><strong>终止条件</strong>：<br>当$\max<em>{s \in S} |V</em>{k+1}(s) - V_k(s)| &lt; \varepsilon$（预设阈值）时停止</p></li><li><p><strong>策略提取</strong>：<br>最终通过最优值函数$V^*$得到确定性策略：</p><script type="math/tex; mode=display">\pi^*(s) = \arg\max_{a \in A} \left[ R(s,a) + \gamma \sum_{s' \in S} P(s' \mid s,a) V^*(s') \right]</script></li></ol><p><strong>特性分析</strong></p><ol><li><p><strong>收敛性</strong>：  </p><ul><li>当$\gamma &lt; 1$时，值迭代以指数速度收敛到唯一最优解</li><li>迭代次数与状态数无关，仅依赖$\gamma$和$\varepsilon$</li></ul></li><li><p><strong>时间复杂度</strong>：<br>每轮迭代复杂度为$O(|S|^2|A|)$，适用于状态空间较小的问题</p></li><li><p><strong>与贝尔曼方程关系</strong>：<br>值迭代本质是不断应用贝尔曼最优算子的不动点迭代</p></li></ol><hr><h2 id="策略迭代（Policy-Iteration）"><a href="#策略迭代（Policy-Iteration）" class="headerlink" title="策略迭代（Policy Iteration）"></a>策略迭代（Policy Iteration）</h2><p><strong>基本思想</strong></p><p>通过<strong>交替进行策略评估（Policy Evaluation）和策略改进（Policy Improvement）</strong>来优化策略，直到收敛到最优策略。</p><p><strong>算法步骤</strong></p><ol><li><p><strong>初始化</strong>：<br>随机选择一个初始策略$\pi_0$</p></li><li><p><strong>策略迭代循环</strong>：<br><strong>Repeat</strong>:  </p><ul><li><p><strong>(1) 策略评估</strong>：<br>计算当前策略$\pi_k$的值函数$V^{\pi_k}$<br>通过求解贝尔曼方程：</p><script type="math/tex; mode=display">V^{\pi_k}(s) = \sum_{a} \pi_k(a|s) \left[ R(s,a) + \gamma \sum_{s'} P(s'|s,a) V^{\pi_k}(s') \right]</script><p>可通过<strong>迭代法</strong>（重复应用上式直至收敛）或<strong>直接求解线性方程组</strong>获得精确解</p></li><li><p><strong>(2) 策略改进</strong>：<br>对每个状态$s$，选择使动作值最大的动作：</p><script type="math/tex; mode=display">\pi_{k+1}(s) = \arg\max_{a} \left[ R(s,a) + \gamma \sum_{s'} P(s'|s,a) V^{\pi_k}(s') \right]</script></li></ul><p><strong>Until</strong> $\pi_{k+1} = \pi_k$（策略稳定，实际上是无限逼近）</p></li></ol><p><strong>特性分析</strong></p><ol><li><p><strong>收敛速度</strong>：  </p><ul><li>通常比值迭代更快（尤其当策略空间较小时）</li><li>策略改进阶段保证每次迭代策略至少不劣化</li></ul></li><li><p><strong>计算复杂度</strong>：  </p><ul><li>策略评估阶段需要$O(|S|^3)$（直接求解）或$O(m|S|^2)$（迭代m次）</li><li>适用于中等规模状态空间问题</li></ul></li></ol><hr><h2 id="截断策略迭代（Truncated-Policy-Iteration）"><a href="#截断策略迭代（Truncated-Policy-Iteration）" class="headerlink" title="截断策略迭代（Truncated Policy Iteration）"></a>截断策略迭代（Truncated Policy Iteration）</h2><p><strong>基本思想</strong></p><p>在标准策略迭代的基础上，<strong>放宽策略评估的精度要求</strong>。通过<strong>限制策略评估阶段的迭代次数</strong>（如固定次数$k$次），提前截断对当前策略的值函数计算，以降低每次迭代的计算量，同时仍能保证策略逐步优化。</p><p><strong>算法步骤</strong></p><ol><li><p><strong>初始化</strong>：  </p><ul><li>随机初始化策略$\pi_0$  </li><li>设置策略评估阶段的迭代次数上限$k$（例如$k=3$）</li></ul></li><li><p><strong>策略迭代循环</strong>：<br><strong>Repeat</strong>:  </p><ul><li><p><strong>(1) 截断策略评估</strong>：<br>对当前策略$\pi_i$，执行以下步骤（从初始值函数$V_0$开始）:  </p><ul><li><p><strong>For</strong> $t=0$ to $k-1$ <strong>do</strong>:<br>更新值函数：  </p><script type="math/tex; mode=display">V_{t+1}(s) = \sum_{a} \pi_i(a|s) \left[ R(s,a) + \gamma \sum_{s'} P(s'|s,a) V_t(s') \right]</script></li><li><p>最终得到近似值函数$V_k \approx V^{\pi_i}$  </p></li></ul></li><li><p><strong>(2) 策略改进</strong>：<br>基于近似值函数$V_k$，贪婪更新策略：  </p><script type="math/tex; mode=display">\pi_{i+1}(s) = \arg\max_{a} \left[ R(s,a) + \gamma \sum_{s'} P(s'|s,a) V_k(s') \right]</script></li></ul><p><strong>Until</strong> $\pi_{i+1} = \pi_i$（策略稳定）</p></li></ol><p><strong>特性分析</strong></p><p><img src="D:/BLOG/source/_posts/RL_studynote/p2.png" alt="收敛速度"></p><ol><li><strong>收敛性</strong>：  <ul><li>即使策略评估未完全收敛，只要策略改进阶段能提升策略，算法仍能收敛到最优策略</li><li>收敛速度可能慢于标准策略迭代，但快于值迭代</li></ul></li><li><strong>精度-效率权衡</strong>：  <ul><li>增大$k$：策略评估更精确，策略改进更有效，但单次迭代时间增加  </li><li>减小$k$：单次迭代更快，但可能需要更多轮次策略迭代</li></ul></li></ol><hr><h2 id="蒙特卡洛方法（Monte-Carlo）"><a href="#蒙特卡洛方法（Monte-Carlo）" class="headerlink" title="蒙特卡洛方法（Monte Carlo）"></a>蒙特卡洛方法（Monte Carlo）</h2><p><strong>基本思想</strong></p><p>蒙特卡洛方法是一种<strong>model-free</strong>的强化学习方法，不依赖环境模型（即无需已知转移概率 $P(s’ \mid s,a)$ 和奖励函数 $R(s,a)$）（隐式，未知给智能体）。它通过<strong>直接与环境交互生成样本轨迹（episode）</strong>，利用样本的回报（return）均值来估计状态值函数或动作值函数。核心是用<strong>经验平均</strong>代替<strong>期望计算</strong>，公式化表示为：</p><script type="math/tex; mode=display">V^{\pi}(s) \approx \frac{1}{N(s)} \sum_{i=1}^{N(s)} G_i(s)</script><p>其中 $G_i(s)$ 是状态 $s$ 在第 $i$ 次轨迹中的累积回报，$N(s)$ 是 $s$ 被访问的次数。</p><p><strong>核心步骤</strong></p><ul><li>策略评估（Policy Evaluation）</li></ul><p>通过采样轨迹估计当前策略 $\pi$ 的值函数：</p><p><strong>首次访问型（First-visit MC）</strong>：仅统计每个状态 $s$ 在一条轨迹中第一次出现时的回报  </p><p><strong>每次访问型（Every-visit MC）</strong>：统计每条轨迹中每次访问状态 $s$ 的回报  </p><p><strong>增量式更新公式</strong>（优化存储效率）：</p><script type="math/tex; mode=display">V(s) \leftarrow V(s) + \alpha \left[ G(s) - V(s) \right]</script><p>其中 $\alpha$ 为学习率，$G(s)$ 是本次轨迹中 $s$ 的回报。</p><ul><li>策略控制（Policy Control）</li></ul><p>通过优化动作值函数 $Q(s,a)$ 改进策略，常用两种方法：</p><p>a. 同轨策略（On-policy）</p><p>使用<strong>与采样相同的策略</strong>进行改进  </p><p>常用 $\varepsilon$-<strong>贪婪策略</strong>平衡探索与利用：</p><script type="math/tex; mode=display">\pi(a \mid s) = \begin{cases} 1- \frac{|A(s)|-1}{|A(s)|}\varepsilon, & a = \arg\max_{a'} Q(s,a') \\\frac{\varepsilon}{|A(s)|}, & \text{其他动作}\end{cases}</script><p>b. 离轨策略（Off-policy）</p><p>使用<strong>行为策略（behavior policy）</strong>生成轨迹，但优化<strong>目标策略（target policy）</strong>  </p><p>通过<strong>重要性采样（Importance Sampling）</strong>修正回报：</p><script type="math/tex; mode=display">V^{\pi}(s) = \mathbb{E}_{\pi_b} \left[ \frac{\pi(a \mid s)}{\pi_b(a \mid s)} G(s) \right]</script><p>算法流程（首次访问型蒙特卡洛控制）</p><ol><li><p><strong>初始化</strong>：  </p><ul><li>随机初始化动作值函数 $Q(s,a)$  </li><li>定义 $\varepsilon$-贪婪策略 $\pi$  </li></ul></li><li><p><strong>生成轨迹</strong>：<br>使用当前策略 $\pi$ 与环境交互，生成完整轨迹  </p><script type="math/tex; mode=display">s_0, a_0, r_1, s_1, a_1, r_2, \dots, s_T</script></li><li><p><strong>更新动作值函数</strong>：<br>对轨迹中每个状态-动作对 $(s_t, a_t)$：  </p><ul><li>计算累积回报 $G<em>t = \sum</em>{k=t}^{T} \gamma^{k-t} r_{k+1}$  </li><li>更新 $Q(s_t, a_t) \leftarrow Q(s_t, a_t) + \alpha (G_t - Q(s_t, a_t))$  </li></ul></li><li><p><strong>策略改进</strong>：<br>根据更新后的 $Q$ 函数，调整 $\varepsilon$-贪婪策略：</p><script type="math/tex; mode=display">\pi(s) = \begin{cases} \arg\max_{a} Q(s,a), & \text{以概率 } 1-\varepsilon \\\text{随机动作}, & \text{以概率 } \varepsilon\end{cases}</script></li><li><p><strong>重复</strong>步骤2-4，直到 $Q$ 函数收敛。</p></li></ol><hr><h2 id="随机近似（Stochastic-Approximation）"><a href="#随机近似（Stochastic-Approximation）" class="headerlink" title="随机近似（Stochastic Approximation）"></a>随机近似（Stochastic Approximation）</h2><p>基本思想</p><p>随机近似是一类通过<strong>带噪声的观测数据迭代逼近目标值</strong>的数学方法，核心是用随机样本逐步修正估计值。其广泛应用于求解无法直接计算期望的优化问题或方程根，尤其在强化学习、信号处理等领域。</p><p><strong>Robbins-Monro 算法</strong></p><p><strong>问题设定</strong>：寻找方程 $g(\theta) = 0$ 的根 $\theta^*$，其中 $g(\theta)$ 的精确值未知，但可通过噪声观测 $Y(\theta) = g(\theta) + \epsilon$ 获取信息。</p><p><strong>迭代公式</strong>：</p><script type="math/tex; mode=display">\theta_{k+1} = \theta_k - \alpha_k Y(\theta_k)</script><p>其中：</p><ul><li><p>$\alpha_k$ 为步长序列，需满足：</p><script type="math/tex; mode=display">\sum_{k=1}^\infty \alpha_k = \infty \quad \text{且} \quad \sum_{k=1}^\infty \alpha_k^2 < \infty</script><p>例如 $\alpha_k = 1/k$。</p></li><li><p>$\epsilon$ 是零均值噪声（$\mathbb{E}[\epsilon] = 0$）。</p></li></ul><p>收敛性保证</p><ul><li><p><strong>条件</strong>：  </p><ol><li>函数 $g(\theta)$ 单调递增且满足增长条件（如 $\theta g(\theta) &gt; 0$ 当 $|\theta|$ 足够大）  </li><li>噪声方差有界：$\mathbb{E}[\epsilon^2] \leq C$  </li><li>步长序列满足Robbins-Monro条件  </li></ol></li><li><p><strong>结论</strong>：  </p><script type="math/tex; mode=display">\lim_{k \to \infty} \theta_k \overset{a.s.}{\longrightarrow} \theta^*</script></li></ul><h2 id="随机梯度下降（Stochastic-Gradient-Descent-SGD）"><a href="#随机梯度下降（Stochastic-Gradient-Descent-SGD）" class="headerlink" title="随机梯度下降（Stochastic Gradient Descent, SGD）"></a>随机梯度下降（Stochastic Gradient Descent, SGD）</h2><p><strong>基本思想</strong></p><p>SGD是<strong>随机近似在优化问题中的特例</strong>，用于最小化经验风险函数：</p><script type="math/tex; mode=display">J(\theta) = \mathbb{E}_{(x,y)\sim \mathcal{D}} [L(f_\theta(x), y)]</script><p>通过每次迭代随机采样一个或少量样本计算梯度估计，更新参数。</p><p>算法步骤</p><ol><li><p><strong>初始化参数</strong>：$\theta_0 \in \mathbb{R}^d$  </p></li><li><p><strong>迭代更新</strong>：<br>对于 $k=1,2,\dots$：  </p><ul><li><p>随机采样小批量样本 $\mathcal{B}<em>k = {(x_i,y_i)}</em>{i=1}^m$  </p></li><li><p>计算随机梯度估计：</p><script type="math/tex; mode=display">\hat{g}_k = \frac{1}{m} \sum_{(x_i,y_i)\in \mathcal{B}_k} \nabla_\theta L(f_\theta(x_i), y_i)</script></li><li><p>更新参数：</p><script type="math/tex; mode=display">\theta_{k+1} = \theta_k - \alpha_k \hat{g}_k</script></li></ul></li></ol><p>关键特性</p><ol><li><strong>计算效率</strong>：  <ul><li>每轮迭代复杂度为 $O(md)$，远低于批量梯度下降的 $O(Nd)$（$N$为总样本数）  </li></ul></li><li><strong>隐式正则化</strong>：  <ul><li>随机噪声使SGD倾向于找到平坦的极小值，提升泛化能力  </li></ul></li><li><strong>收敛性</strong>：  <ul><li>在凸问题中，SGD以 $O(1/\sqrt{k})$ 速率收敛  </li><li>非凸问题中收敛到局部极小值或鞍点  </li></ul></li></ol><p><strong>与批量梯度下降对比</strong></p><div class="table-container"><table><thead><tr><th>特性</th><th>SGD</th><th>批量梯度下降（BGD）</th></tr></thead><tbody><tr><td><strong>每轮计算量</strong></td><td>低（小批量）</td><td>高（全数据集）</td></tr><tr><td><strong>收敛路径</strong></td><td>震荡较大</td><td>平滑</td></tr><tr><td><strong>局部极小值逃脱</strong></td><td>更强（噪声帮助逃离鞍点）</td><td>较弱</td></tr><tr><td><strong>在线学习</strong></td><td>支持</td><td>不支持</td></tr></tbody></table></div><p><strong>实际应用示例：线性回归</strong></p><p><strong>目标函数</strong>：</p><script type="math/tex; mode=display">J(w) = \frac{1}{2N} \sum_{i=1}^N (w^T x_i - y_i)^2</script><p><strong>SGD更新步骤</strong>：</p><ol><li><p>随机采样样本 $(x_i, y_i)$  </p></li><li><p>计算梯度：</p><script type="math/tex; mode=display">\nabla_w L = (w^T x_i - y_i) x_i</script></li><li><p>更新权重：</p><script type="math/tex; mode=display">w_{k+1} = w_k - \alpha (w_k^T x_i - y_i) x_i</script></li></ol><p><strong>P.S.:</strong></p><ol><li><strong>SA与SGD的统一性</strong>：<br>SGD可视为求解 $\nabla J(\theta) = 0$ 的随机近似过程。</li><li><strong>步长设计</strong>：  <ul><li>恒定步长：快速收敛但可能震荡  </li><li>递减步长：保证收敛但速度变慢  </li><li>自适应步长（如Adam）：平衡速度与稳定性  </li></ul></li><li><strong>噪声的双重作用</strong>：  <ul><li>负面：增加方差，延缓收敛  </li><li>正面：帮助逃离局部极小，提升泛化  </li></ul></li></ol><hr><h2 id="时序差分学习（Temporal-Difference-Learning）"><a href="#时序差分学习（Temporal-Difference-Learning）" class="headerlink" title="时序差分学习（Temporal Difference Learning）"></a>时序差分学习（Temporal Difference Learning）</h2><h3 id="TD-Learning-of-State-Values-TD-0"><a href="#TD-Learning-of-State-Values-TD-0" class="headerlink" title="TD Learning of State Values (TD(0))"></a>TD Learning of State Values (TD(0))</h3><p><strong>基本思想</strong>  </p><p>通过<strong>自举（bootstrapping）</strong>结合当前估计值与即时奖励，在线更新状态值函数，无需等待完整轨迹结束。</p><p><strong>算法步骤</strong>  </p><ol><li><p>初始化值函数 $V(s)$  </p></li><li><p>在每个时间步 $t$：  </p><ul><li><p>观察当前状态 $s<em>t$，执行动作 $a_t$，获得奖励 $r</em>{t+1}$，转移到状态 $s_{t+1}$  </p></li><li><p>计算 <strong>TD误差</strong>：  </p><script type="math/tex; mode=display">\delta_t = r_{t+1} + \gamma V(s_{t+1}) - V(s_t)</script></li><li><p>更新值函数：  </p><script type="math/tex; mode=display">V(s_t) \leftarrow V(s_t) + \alpha \delta_t</script><p>（$\alpha$ 为学习率）</p></li></ul></li></ol><p><strong>特性</strong>  </p><ul><li><strong>在线更新</strong>：单步即可更新，无需等待轨迹结束  </li><li><strong>方差较低</strong>：相比蒙特卡洛方法，TD误差的方差更小  </li><li><strong>收敛性</strong>：在策略下，$V(s)$ 以概率1收敛到真实值函数 $V^\pi(s)$  </li></ul><hr><h3 id="TD-Learning-of-Action-Values-Sarsa"><a href="#TD-Learning-of-Action-Values-Sarsa" class="headerlink" title="TD Learning of Action Values: Sarsa"></a>TD Learning of Action Values: Sarsa</h3><p><strong>基本思想</strong>  </p><p><strong>同轨策略（on-policy）</strong>更新动作值函数 $Q(s,a)$，使用当前策略选择下一个动作 $a’$，更新公式为：</p><script type="math/tex; mode=display">Q(s_t,a_t) \leftarrow Q(s_t,a_t) + \alpha \left[ r_{t+1} + \gamma Q(s_{t+1},a_{t+1}) - Q(s_t,a_t) \right]</script><p><strong>算法步骤</strong>  </p><ol><li>初始化 $Q(s,a)$，定义 $\varepsilon$-贪婪策略  </li><li>生成轨迹：  <ul><li>在状态 $s_t$ 选择动作 $a_t$（按 $\varepsilon$-贪婪策略）  </li><li>执行 $a<em>t$，获得 $r</em>{t+1}$ 和 $s_{t+1}$  </li><li>在 $s<em>{t+1}$ 选择动作 $a</em>{t+1}$（同样按 $\varepsilon$-贪婪策略）  </li></ul></li><li>更新 $Q(s_t,a_t)$  </li><li>重复直到收敛  </li></ol><p><strong>特性</strong>  </p><ul><li><strong>策略依赖</strong>：更新依赖于当前策略的后续动作选择  </li><li><strong>安全探索</strong>：通过 $\varepsilon$-贪婪平衡探索与利用  </li><li><strong>收敛性</strong>：需满足无限访问条件，且在策略下收敛到最优 $Q^\pi$  </li></ul><hr><h3 id="TD-Learning-of-Action-Values-Expected-Sarsa"><a href="#TD-Learning-of-Action-Values-Expected-Sarsa" class="headerlink" title="TD Learning of Action Values: Expected Sarsa"></a>TD Learning of Action Values: Expected Sarsa</h3><p><strong>基本思想</strong>  </p><p>改进Sarsa，使用<strong>期望值</strong>替代下一个动作的采样值，减少方差：</p><script type="math/tex; mode=display">Q(s_t,a_t) \leftarrow Q(s_t,a_t) + \alpha \left[ r_{t+1} + \gamma \mathbb{E}_{a'} Q(s_{t+1},a') - Q(s_t,a_t) \right]</script><p>其中期望值计算为：</p><script type="math/tex; mode=display">\mathbb{E}_{a'} Q(s_{t+1},a') = \sum_{a'} \pi(a'|s_{t+1}) Q(s_{t+1},a')</script><p><strong>算法步骤</strong>  </p><p>与Sarsa类似，但更新时计算所有可能动作的期望值而非采样单个动作。</p><p><strong>特性</strong>  </p><ul><li><strong>方差更低</strong>：相比Sarsa，消除了下一个动作的随机性  </li><li><strong>灵活性</strong>：可离线策略使用（例如目标策略与行为策略不同）  </li><li><strong>计算开销</strong>：需遍历所有动作计算期望，适合动作空间较小的问题  </li></ul><hr><h3 id="TD-Learning-of-Action-Values-n-step-Sarsa"><a href="#TD-Learning-of-Action-Values-n-step-Sarsa" class="headerlink" title="TD Learning of Action Values: n-step Sarsa"></a>TD Learning of Action Values: n-step Sarsa</h3><p><strong>基本思想</strong>  </p><p>结合蒙特卡洛的多步回报与TD的自举，平衡偏差与方差。定义 <strong>n步回报</strong>：</p><script type="math/tex; mode=display">G_{t:t+n} = r_{t+1} + \gamma r_{t+2} + \dots + \gamma^{n-1} r_{t+n} + \gamma^n Q(s_{t+n},a_{t+n})</script><p>更新公式：</p><script type="math/tex; mode=display">Q(s_t,a_t) \leftarrow Q(s_t,a_t) + \alpha \left[ G_{t:t+n} - Q(s_t,a_t) \right]</script><p><strong>算法步骤</strong>  </p><ol><li>初始化 $Q(s,a)$，生成轨迹  </li><li>对每个状态-动作对 $(s_t,a_t)$，累积后续 $n$ 步的奖励  </li><li>使用 $n$ 步回报更新 $Q(s_t,a_t)$  </li></ol><p><strong>特性</strong>  </p><ul><li><strong>n=1</strong>：退化为Sarsa  </li><li><strong>n→∞</strong>：退化为蒙特卡洛方法  </li><li><strong>折中效果</strong>：n步平衡即时奖励与长期回报的估计  </li></ul><hr><h3 id="TD-Learning-of-Optimal-Action-Values-Q-learning"><a href="#TD-Learning-of-Optimal-Action-Values-Q-learning" class="headerlink" title="TD Learning of Optimal Action Values: Q-learning"></a>TD Learning of Optimal Action Values: Q-learning</h3><p><strong>基本思想</strong>  </p><p><strong>离轨策略（off-policy）</strong>直接学习最优动作值函数 $Q^*$，更新公式为：</p><script type="math/tex; mode=display">Q(s_t,a_t) \leftarrow Q(s_t,a_t) + \alpha \left[ r_{t+1} + \gamma \max_{a'} Q(s_{t+1},a') - Q(s_t,a_t) \right]</script><p><strong>算法步骤</strong>  </p><ol><li>初始化 $Q(s,a)$，定义行为策略（如 $\varepsilon$-贪婪）  </li><li>生成轨迹：  <ul><li>在状态 $s_t$ 选择动作 $a_t$（按行为策略）  </li><li>执行 $a<em>t$，获得 $r</em>{t+1}$ 和 $s_{t+1}$  </li></ul></li><li>更新 $Q(s<em>t,a_t)$ 时使用 $\max</em>{a’} Q(s_{t+1},a’)$（目标策略为贪婪策略）  </li><li>重复直到收敛  </li></ol><p><strong>特性</strong>  </p><ul><li><strong>离轨策略</strong>：行为策略（探索）与目标策略（利用）分离  </li><li><strong>直接优化</strong>：通过最大化操作直接逼近最优策略  </li><li><strong>收敛性</strong>：在有限MDP中，以概率1收敛到 $Q^*$  </li></ul><hr><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><div class="table-container"><table><thead><tr><th>方法</th><th>更新公式</th><th>策略类型</th><th>关键特性</th></tr></thead><tbody><tr><td><strong>TD(0)</strong></td><td>$V(s) \leftarrow V(s) + \alpha [r + \gamma V(s’) - V(s)]$</td><td>同轨策略</td><td>低方差，在线更新</td></tr><tr><td><strong>Sarsa</strong></td><td>$Q(s,a) \leftarrow Q(s,a) + \alpha [r + \gamma Q(s’,a’) - Q(s,a)]$</td><td>同轨策略</td><td>依赖当前策略，安全探索</td></tr><tr><td><strong>Expected Sarsa</strong></td><td>$Q(s,a) \leftarrow Q(s,a) + \alpha [r + \gamma \mathbb{E}_{a’} Q(s’,a’) - Q(s,a)]$</td><td>可离轨策略</td><td>低方差，计算期望</td></tr><tr><td><strong>n-step Sarsa</strong></td><td>$Q(s,a) \leftarrow Q(s,a) + \alpha [G_{t:t+n} - Q(s,a)]$</td><td>同轨策略</td><td>平衡TD与MC，多步回报</td></tr><tr><td><strong>Q-learning</strong></td><td>$Q(s,a) \leftarrow Q(s,a) + \alpha [r + \gamma \max_{a’} Q(s’,a’) - Q(s,a)]$</td><td>离轨策略</td><td>直接优化，最大化操作</td></tr></tbody></table></div><p><img src="D:/BLOG/source/_posts/RL_studynote/p3.png" alt="算法对比1"></p><p><img src="D:/BLOG/source/_posts/RL_studynote/p4.png" alt="算法对比2"></p><hr><h2 id="值函数近似（Value-Function-Approximation）"><a href="#值函数近似（Value-Function-Approximation）" class="headerlink" title="值函数近似（Value Function Approximation）"></a>值函数近似（Value Function Approximation）</h2><h3 id="算法框架：状态值函数估计"><a href="#算法框架：状态值函数估计" class="headerlink" title="算法框架：状态值函数估计"></a>算法框架：状态值函数估计</h3><p>当状态空间巨大或连续时，无法用表格存储每个状态值。使用参数化函数 $V(s; \mathbf{w}) \approx V^\pi(s)$ 近似真实值函数，其中 $\mathbf{w}$ 为可调参数。</p><p><strong>算法步骤</strong>  </p><ol><li><p><strong>初始化参数</strong>：随机初始化权重 $\mathbf{w}$  </p></li><li><p><strong>交互采样</strong>：通过策略 $\pi$ 生成轨迹，收集经验 $(s<em>t, r</em>{t+1}, s_{t+1})$  </p></li><li><p><strong>计算TD误差</strong>：  </p><script type="math/tex; mode=display">\delta_t = r_{t+1} + \gamma V(s_{t+1}; \mathbf{w}) - V(s_t; \mathbf{w})</script></li><li><p><strong>更新参数</strong>：沿减小TD误差的方向调整 $\mathbf{w}$：  </p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} + \alpha \delta_t \nabla_{\mathbf{w}} V(s_t; \mathbf{w})</script><p>（$\alpha$ 为学习率）</p></li></ol><p><strong>目标函数</strong>  </p><p>最小化均方误差（Mean Squared Error, MSE）：  </p><script type="math/tex; mode=display">J(\mathbf{w}) = \mathbb{E}_{(s) \sim \pi} \left[ \left( V^\pi(s) - V(s; \mathbf{w}) \right)^2 \right]</script><p>实际中通过采样近似：  </p><script type="math/tex; mode=display">J(\mathbf{w}) \approx \frac{1}{N} \sum_{i=1}^N \left( V^\pi(s_i) - V(s_i; \mathbf{w}) \right)^2</script><p><strong>优化算法</strong>  </p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th><th>公式</th></tr></thead><tbody><tr><td><strong>随机梯度下降</strong></td><td>逐样本更新，降低计算量</td><td>$\mathbf{w} \leftarrow \mathbf{w} - \alpha \nabla_{\mathbf{w}} J(\mathbf{w})$</td></tr><tr><td><strong>批量梯度下降</strong></td><td>全数据集计算梯度，收敛稳定但效率低</td><td>$\mathbf{w} \leftarrow \mathbf{w} - \alpha \sum<em>{i=1}^N \nabla</em>{\mathbf{w}} J_i(\mathbf{w})$</td></tr><tr><td><strong>小批量梯度下降</strong></td><td>折中方案，常用在深度学习</td><td>$\mathbf{w} \leftarrow \mathbf{w} - \frac{\alpha}{m} \sum<em>{i=1}^m \nabla</em>{\mathbf{w}} J_i(\mathbf{w})$</td></tr><tr><td><strong>最小二乘法</strong></td><td>仅适用于线性模型，解析解高效</td><td>$\mathbf{w} = (\mathbf{X}^T \mathbf{X})^{-1} \mathbf{X}^T \mathbf{y}$</td></tr></tbody></table></div><p><strong>函数逼近器选择</strong>  </p><div class="table-container"><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>线性模型</strong></td><td>计算简单，理论收敛性明确</td><td>表达能力有限</td><td>低维状态空间</td></tr><tr><td><strong>多项式基函数</strong></td><td>可扩展非线性特征</td><td>特征工程依赖先验知识</td><td>中等维度状态空间</td></tr><tr><td><strong>神经网络</strong></td><td>高表达能力，自动特征提取</td><td>训练不稳定，易过拟合</td><td>高维/连续状态空间</td></tr><tr><td><strong>决策树</strong></td><td>可解释性强</td><td>不适合连续动作空间</td><td>离散状态空间</td></tr></tbody></table></div><h3 id="Sarsa-with-Function-Approximation"><a href="#Sarsa-with-Function-Approximation" class="headerlink" title="Sarsa with Function Approximation"></a>Sarsa with Function Approximation</h3><ul><li><p><strong>动作值函数近似</strong>：用 $Q(s,a; \mathbf{w}) \approx Q^\pi(s,a)$  </p></li><li><p><strong>TD误差</strong>：  </p><script type="math/tex; mode=display">\delta_t = r_{t+1} + \gamma Q(s_{t+1}, a_{t+1}; \mathbf{w}) - Q(s_t, a_t; \mathbf{w})</script></li><li><p><strong>参数更新</strong>：  </p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} + \alpha \delta_t \nabla_{\mathbf{w}} Q(s_t, a_t; \mathbf{w})</script></li></ul><h3 id="Q-learning-with-Function-Approximation"><a href="#Q-learning-with-Function-Approximation" class="headerlink" title="Q-learning with Function Approximation"></a>Q-learning with Function Approximation</h3><ul><li><p><strong>TD误差</strong>：  </p><script type="math/tex; mode=display">\delta_t = r_{t+1} + \gamma \max_{a'} Q(s_{t+1}, a'; \mathbf{w}) - Q(s_t, a_t; \mathbf{w})</script></li><li><p><strong>参数更新</strong>：  </p><script type="math/tex; mode=display">\mathbf{w} \leftarrow \mathbf{w} + \alpha \delta_t \nabla_{\mathbf{w}} Q(s_t, a_t; \mathbf{w})</script></li></ul><h3 id="Deep-Q-Learning-DQN"><a href="#Deep-Q-Learning-DQN" class="headerlink" title="Deep Q-Learning (DQN)"></a>Deep Q-Learning (DQN)</h3><ul><li><p><strong>神经网络逼近</strong>：用深度网络 $Q(s,a; \mathbf{w})$ 替代线性模型  </p></li><li><p><strong>经验回放（Experience Replay）</strong>：<br>存储经验 $(s<em>t, a_t, r</em>{t+1}, s_{t+1})$​ 到缓冲池，随机采样打破相关性  </p><script type="math/tex; mode=display">\text{Sample } (s_i, a_i, r_{i+1}, s_{i+1}) \sim \mathcal{D}</script><script type="math/tex; mode=display">\text{Update } Q \text{ using TD error: } \delta = r + \gamma \max_{a'} Q(s', a'; \mathbf{w}^-) - Q(s, a; \mathbf{w})</script></li></ul><ul><li><strong>目标网络（Target Network）</strong>：<br>Q-learning的TD目标 $r + \gamma \max_{a’} Q(s’,a’;\mathbf{w})$ 与当前网络参数 $\mathbf{w}$ 相关，导致目标值随训练不断变化（目标移动），训练震荡。所以使用独立参数 $\mathbf{w}^-$ 计算TD目标，缓解波动，稳定训练：  <script type="math/tex; mode=display">\delta_t = r_{t+1} + \gamma \max_{a'} Q(s_{t+1}, a'; \mathbf{w}^-) - Q(s_t, a_t; \mathbf{w})</script></li></ul><p>训练流程  </p><ol><li>初始化当前网络 $Q(\mathbf{w})$ 和目标网络 $Q(\mathbf{w}^-)$  </li><li>收集经验并存入缓冲池  </li><li>随机采样小批量经验，计算TD误差  </li><li>反向传播更新 $\mathbf{w}$  </li><li>每隔 $C$ 步同步 $\mathbf{w}^- \leftarrow \mathbf{w}$  </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Initialize Q-network Q(w) <span class="keyword">and</span> target network Q(w^-) <span class="keyword">with</span> w^- = w</span><br><span class="line">Initialize replay buffer D</span><br><span class="line"><span class="keyword">for</span> episode = <span class="number">1</span> to M:</span><br><span class="line">    s = env.reset()</span><br><span class="line">    <span class="keyword">for</span> t = <span class="number">1</span> to T:</span><br><span class="line">        <span class="comment"># 1. ε-贪婪策略选择动作</span></span><br><span class="line">        a = ε-greedy(Q(s; w))</span><br><span class="line">        <span class="comment"># 2. 执行动作，获取经验</span></span><br><span class="line">        s<span class="string">&#x27;, r, done = env.step(a)</span></span><br><span class="line"><span class="string">        # 3. 存储经验到缓冲池</span></span><br><span class="line"><span class="string">        D.add((s, a, r, s&#x27;</span>, done))</span><br><span class="line">        s = s<span class="string">&#x27;</span></span><br><span class="line"><span class="string">        # 4. 从缓冲池采样并更新网络</span></span><br><span class="line"><span class="string">        if len(D) &gt; batch_size:</span></span><br><span class="line"><span class="string">            batch = D.sample(batch_size)</span></span><br><span class="line"><span class="string">            # 计算目标Q值</span></span><br><span class="line"><span class="string">            targets = r + γ * max(Q(s&#x27;</span>; w^-)) * (<span class="number">1</span> - done)</span><br><span class="line">            <span class="comment"># 计算损失</span></span><br><span class="line">            loss = MSE(Q(s,a; w), targets)</span><br><span class="line">            <span class="comment"># 梯度下降更新w</span></span><br><span class="line">            w = AdamOptimizer.minimize(loss)</span><br><span class="line">            <span class="comment"># 每隔C步同步目标网络</span></span><br><span class="line">            <span class="keyword">if</span> t % C == <span class="number">0</span>:</span><br><span class="line">                w^- = w</span><br></pre></td></tr></table></figure><hr><h2 id="策略梯度方法（Policy-Gradient-Methods）"><a href="#策略梯度方法（Policy-Gradient-Methods）" class="headerlink" title="策略梯度方法（Policy Gradient Methods）"></a>策略梯度方法（Policy Gradient Methods）</h2><p><strong>策略梯度的基本思想</strong></p><p><strong>核心概念</strong></p><ul><li><p><strong>直接优化策略</strong>：不同于值函数方法（如Q-learning）间接通过优化值函数来改进策略，策略梯度方法<strong>直接参数化策略</strong> $\pi_\theta(a|s)$（如神经网络），并通过梯度上升最大化预期回报。</p></li><li><p><strong>策略参数化</strong>：使用可微函数（如神经网络）表示策略，参数为 $\theta$，输出动作的概率分布：  </p><script type="math/tex; mode=display">\pi_\theta(a|s) = \mathbb{P}[a|s; \theta]</script></li><li><p><strong>目标</strong>：找到最优参数 $\theta^*$，使得策略在环境中获得的累积回报最大。</p></li></ul><p> <strong>衡量策略优劣的指标</strong></p><p><strong>(1) 平均奖励（Average Reward）</strong></p><p>适用于<strong>持续任务</strong>（无终止状态）：  </p><script type="math/tex; mode=display">J(\theta) = \lim_{T \to \infty} \frac{1}{T} \mathbb{E}\left[ \sum_{t=1}^T r_t \right]</script><p><strong>(2) 折扣平均奖励（Discounted Return）</strong></p><p>适用于<strong>有终止状态</strong>的任务：  </p><script type="math/tex; mode=display">J(\theta) = \mathbb{E}\left[ \sum_{t=0}^\infty \gamma^t r_{t+1} \right]</script><p>其中轨迹的初始状态分布为 $s_0 \sim \mu(s_0)$（如均匀分布）。</p><p><strong>目标函数的梯度计算</strong></p><p><strong>策略梯度定理（Policy Gradient Theorem）</strong></p><p>无论采用平均奖励还是折扣奖励目标，策略梯度均可表示为：</p><script type="math/tex; mode=display">\nabla_\theta J(\theta) = \mathbb{E}_{\pi_\theta} \left[ \nabla_\theta \ln \pi_\theta(a|s) \cdot Q^{\pi_\theta}(s,a) \right]</script><ul><li><p><strong>直观解释</strong>：通过增加高回报动作的概率来优化策略。</p></li><li><p><strong>推导关键</strong>：使用<strong>似然比技巧（Likelihood Ratio Trick）</strong>将梯度转换为期望形式，从而可通过样本近似。</p></li><li><p><strong>$\nabla<em>\theta \ln \pi</em>\theta(a|s)$</strong>：策略的概率变化方向。</p></li><li><p><strong>$Q^{\pi_\theta}(s,a)$</strong>：动作的价值，作为权重调整更新幅度。</p></li></ul><p><strong>两种场景的梯度形式</strong></p><ol><li><p><strong>平均奖励</strong>：  </p><script type="math/tex; mode=display">\nabla_\theta J(\theta) = \mathbb{E}_{\pi_\theta} \left[ \nabla_\theta \ln \pi_\theta(a|s) \cdot \left( Q^{\pi_\theta}(s,a) - b(s) \right) \right]</script><p>（$b(s)$ 为基线函数，用于降低方差）</p></li><li><p><strong>折扣奖励</strong>：  </p><script type="math/tex; mode=display">\nabla_\theta J(\theta) = \mathbb{E}_{\pi_\theta} \left[ \nabla_\theta \ln \pi_\theta(a|s) \cdot G_t \right]</script><p>（$G<em>t = \sum</em>{k=0}^\infty \gamma^k r_{t+k+1}$ 为累积回报）</p></li></ol><p><strong>梯度上升算法（REINFORCE）</strong></p><p><strong>算法原理</strong></p><p>REINFORCE 是最基础的策略梯度算法，属于<strong>蒙特卡洛方法</strong>（需完整轨迹）。其核心是通过采样轨迹估计梯度，更新策略参数。</p><p><strong>算法步骤</strong></p><ol><li><p><strong>初始化策略参数</strong> $\theta$。</p></li><li><p><strong>循环以下步骤</strong>：<br>a. <strong>生成轨迹</strong>：使用当前策略 $\pi<em>\theta$ 与环境交互，得到轨迹 $\tau = (s_0,a_0,r_1,s_1,a_1,r_2,\dots,s_T)$。<br>b. <strong>计算累积回报</strong>：对每个时间步 $t$，计算 $G_t = \sum</em>{k=t}^{T} \gamma^{k-t} r_{k+1}$。<br>c. <strong>估计梯度</strong>：  </p><script type="math/tex; mode=display">   \nabla_\theta J(\theta) \approx \frac{1}{T} \sum_{t=0}^{T} \nabla_\theta \ln \pi_\theta(a_t|s_t) \cdot G_t</script><p>d. <strong>更新参数</strong>：  </p><script type="math/tex; mode=display">   \theta \leftarrow \theta + \alpha \nabla_\theta J(\theta)</script><p>   （$\alpha$ 为学习率）</p></li></ol><p><strong>改进：引入基线（Baseline）</strong></p><p>为减少方差，可在梯度估计中减去基线函数 $b(s)$（通常选择状态值函数 $V(s)$）：  </p><script type="math/tex; mode=display">\nabla_\theta J(\theta) \approx \frac{1}{T} \sum_{t=0}^{T} \nabla_\theta \ln \pi_\theta(a_t|s_t) \cdot (G_t - b(s_t))</script><ul><li><strong>常见选择</strong>：  <ul><li>$b(s) = V^{\pi_\theta}(s)$ → 得到 <strong>Advantage Function</strong> $A(s,a) = Q(s,a) - V(s)$  </li><li>通过神经网络近似 $V(s)$（如Actor-Critic方法）</li></ul></li></ul><p><strong>REINFORCE 伪代码示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">REINFORCE</span>(<span class="params">env, policy, alpha=<span class="number">0.01</span>, gamma=<span class="number">0.99</span>, num_episodes=<span class="number">1000</span></span>):</span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(num_episodes):</span><br><span class="line">        states, actions, rewards = [], [], []</span><br><span class="line">        s = env.reset()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">            a = policy.sample_action(s)  <span class="comment"># 按策略采样动作</span></span><br><span class="line">            s_next, r, done = env.step(a)</span><br><span class="line">            states.append(s)</span><br><span class="line">            actions.append(a)</span><br><span class="line">            rewards.append(r)</span><br><span class="line">            s = s_next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算累积回报</span></span><br><span class="line">        G = <span class="number">0</span></span><br><span class="line">        returns = []</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">reversed</span>(rewards):</span><br><span class="line">            G = r + gamma * G</span><br><span class="line">            returns.insert(<span class="number">0</span>, G)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新策略参数</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(states)):</span><br><span class="line">            s_t, a_t, G_t = states[t], actions[t], returns[t]</span><br><span class="line">            grad_log_prob = policy.grad_log_prob(s_t, a_t)  <span class="comment"># 计算梯度</span></span><br><span class="line">            policy.theta += alpha * grad_log_prob * G_t  <span class="comment"># 梯度上升</span></span><br><span class="line">    <span class="keyword">return</span> policy</span><br></pre></td></tr></table></figure><p><strong>REINFORCE的优缺点</strong></p><div class="table-container"><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>简单易实现</td><td>高方差（需大量轨迹）</td></tr><tr><td>支持连续动作空间</td><td>蒙特卡洛更新效率低</td></tr><tr><td>直接优化策略</td><td>无偏但收敛慢</td></tr></tbody></table></div><p><strong>策略梯度 vs 值函数方法</strong></p><div class="table-container"><table><thead><tr><th>维度</th><th>策略梯度</th><th>值函数方法（如Q-learning）</th></tr></thead><tbody><tr><td><strong>优化目标</strong></td><td>直接优化策略参数 $\theta$</td><td>优化值函数，间接推导策略</td></tr><tr><td><strong>动作空间</strong></td><td>天然支持连续动作</td><td>需离散化动作</td></tr><tr><td><strong>策略类型</strong></td><td>显式策略（可随机）</td><td>隐式策略（通常确定性）</td></tr><tr><td><strong>方差与偏差</strong></td><td>无偏，高方差</td><td>有偏（函数近似误差），低方差</td></tr></tbody></table></div><hr><h2 id="Actor-Critic-方法"><a href="#Actor-Critic-方法" class="headerlink" title="Actor-Critic 方法"></a>Actor-Critic 方法</h2><p><strong>基本思想</strong></p><ul><li><strong>Actor</strong>：参数化策略 $\pi_\theta(a|s)$，负责生成动作。  </li><li><strong>Critic</strong>：参数化动作值函数 $Q_w(s,a)$，评估动作的优劣并提供反馈。  </li><li><strong>更新规则</strong>：结合策略梯度和Q值估计，直接利用Critic的反馈调整Actor。</li></ul><p><strong>算法步骤</strong></p><ol><li><strong>初始化</strong>：策略参数 $\theta$ 和Critic参数 $w$。  </li><li><strong>交互采样</strong>：使用当前策略生成轨迹 $(s<em>t, a_t, r</em>{t+1}, s_{t+1})$。  </li><li><strong>Critic更新</strong>：通过TD误差更新 $Q_w$：  <script type="math/tex; mode=display">\delta_t = r_{t+1} + \gamma Q_w(s_{t+1}, a_{t+1}) - Q_w(s_t, a_t)</script><script type="math/tex; mode=display">w \leftarrow w + \alpha_w \delta_t \nabla_w Q_w(s_t, a_t)</script></li><li><strong>Actor更新</strong>：利用Critic的Q值计算策略梯度：  <script type="math/tex; mode=display">\nabla_\theta J(\theta) = \mathbb{E} \left[ \nabla_\theta \ln \pi_\theta(a_t|s_t) \cdot Q_w(s_t, a_t) \right]</script><script type="math/tex; mode=display">\theta \leftarrow \theta + \alpha_\theta \nabla_\theta J(\theta)</script></li></ol><p><strong>特性</strong></p><ul><li><strong>在线更新</strong>：单步TD误差，无需等待完整轨迹。  </li><li><strong>高偏差低方差</strong>：Critic的Q值估计引入偏差，但方差低于蒙特卡洛方法。  </li></ul><h3 id="Advantage-Actor-Critic"><a href="#Advantage-Actor-Critic" class="headerlink" title="Advantage Actor-Critic"></a>Advantage Actor-Critic</h3><p><strong>基线不变性（Baseline Invariance）</strong></p><ul><li><strong>核心思想</strong>：在策略梯度中引入基线函数 $b(s)$，其选择不影响梯度估计的无偏性，但可降低方差。  </li><li><strong>数学表达</strong>：  <script type="math/tex; mode=display">\nabla_\theta J(\theta) = \mathbb{E} \left[ \nabla_\theta \ln \pi_\theta(a|s) \cdot (Q^\pi(s,a) - b(s)) \right]</script>若 $b(s)$ 与动作 $a$ 无关，则梯度估计仍无偏。  </li><li><strong>最优基线</strong>：选择 $b(s) = V^\pi(s)$ 时方差最小。  </li></ul><p><strong>优势函数（Advantage Function）</strong></p><ul><li><strong>定义</strong>：  <script type="math/tex; mode=display">A^\pi(s,a) = Q^\pi(s,a) - V^\pi(s)</script>表示动作 $a$ 相对于平均水平的优势。  </li><li><strong>特性</strong>：  <ul><li>$\mathbb{E}_{a \sim \pi}[A^\pi(s,a)] = 0$  </li><li>减少方差，提升学习稳定性。  </li></ul></li></ul><p><strong>A2C算法步骤</strong></p><ol><li><strong>定义Critic</strong>：参数化状态值函数 $V_v(s)$。  </li><li><strong>计算优势估计</strong>：  <script type="math/tex; mode=display">\delta_t = r_{t+1} + \gamma V_v(s_{t+1}) - V_v(s_t) \quad (\text{TD误差即优势估计})</script></li><li><strong>Critic更新</strong>：  <script type="math/tex; mode=display">v \leftarrow v + \alpha_v \delta_t \nabla_v V_v(s_t)</script></li><li><strong>Actor更新</strong>：  <script type="math/tex; mode=display">\theta \leftarrow \theta + \alpha_\theta \nabla_\theta \ln \pi_\theta(a_t|s_t) \cdot \delta_t</script></li></ol><p><strong>特性</strong></p><ul><li><strong>低方差</strong>：优势函数替代Q值，减少估计波动。  </li><li><strong>单Critic网络</strong>：只需估计 $V(s)$，计算量低于QAC。  </li></ul><hr><h3 id="Off-Policy-Actor-Critic"><a href="#Off-Policy-Actor-Critic" class="headerlink" title="Off-Policy Actor-Critic"></a>Off-Policy Actor-Critic</h3><p><strong>重要性采样（Importance Sampling）</strong></p><ul><li><strong>目标</strong>：从行为策略 $\beta(a|s)$ 生成的样本中学习目标策略 $\pi_\theta(a|s)$。  </li><li><strong>重要性权重</strong>：  <script type="math/tex; mode=display">\rho_t = \frac{\pi_\theta(a_t|s_t)}{\beta(a_t|s_t)}</script>修正动作概率分布的偏差。  </li></ul><p><strong>离轨策略梯度定理</strong></p><script type="math/tex; mode=display">\nabla_\theta J(\theta) = \mathbb{E}_{s \sim \beta} \left[ \sum_a \pi_\theta(a|s) \nabla_\theta \ln \pi_\theta(a|s) \cdot Q^\pi(s,a) \right]</script><p>通过重要性采样转换为：  </p><script type="math/tex; mode=display">\nabla_\theta J(\theta) \approx \mathbb{E}_{(s,a) \sim \beta} \left[ \rho_t \nabla_\theta \ln \pi_\theta(a|s) \cdot Q_w(s,a) \right]</script><p><strong>离轨Actor-Critic算法步骤</strong></p><ol><li><strong>生成轨迹</strong>：使用行为策略 $\beta$ 采样 $(s<em>t, a_t, r</em>{t+1}, s_{t+1})$。  </li><li><strong>计算重要性权重</strong>：  <script type="math/tex; mode=display">\rho_t = \frac{\pi_\theta(a_t|s_t)}{\beta(a_t|s_t)}</script></li><li><strong>Critic更新</strong>：通过离轨TD误差更新 $Q_w$ 或 $V_v$。  </li><li><strong>Actor更新</strong>：  <script type="math/tex; mode=display">\theta \leftarrow \theta + \alpha_\theta \rho_t \nabla_\theta \ln \pi_\theta(a_t|s_t) \cdot \delta_t</script></li></ol><h3 id="Deterministic-Policy-Gradient"><a href="#Deterministic-Policy-Gradient" class="headerlink" title="Deterministic Policy Gradient"></a>Deterministic Policy Gradient</h3><p><strong>确定性策略梯度定理</strong></p><ul><li><p><strong>策略定义</strong>：确定性策略 $a = \mu_\theta(s)$。  </p></li><li><p><strong>梯度公式</strong>：  </p><script type="math/tex; mode=display">\nabla_\theta J(\theta) = \mathbb{E}_{s \sim \rho^\mu} \left[ \nabla_\theta \mu_\theta(s) \cdot \nabla_a Q^\mu(s,a) \big|_{a=\mu_\theta(s)} \right]</script><p>其中 $\rho^\mu(s)$ 是状态分布。  </p></li></ul><p><strong>确定性Actor-Critic算法（DPG）</strong></p><ol><li><strong>Critic更新</strong>：最小化Q值估计的均方误差：  <script type="math/tex; mode=display">L(w) = \mathbb{E} \left[ (r + \gamma Q_w(s', \mu_\theta(s')) - Q_w(s,a))^2 \right]</script></li><li><strong>Actor更新</strong>：沿Q值梯度方向提升策略：  <script type="math/tex; mode=display">\theta \leftarrow \theta + \alpha_\theta \nabla_\theta \mu_\theta(s) \cdot \nabla_a Q_w(s,a) \big|_{a=\mu_\theta(s)}</script></li></ol><p><strong>深度确定性策略梯度（DDPG）</strong></p><ul><li><strong>关键技术</strong>：  <ul><li><strong>经验回放</strong>：存储转移样本 $(s,a,r,s’)$。  </li><li><strong>目标网络</strong>：软更新Actor和Critic目标网络（$\tau \ll 1$）：  <script type="math/tex; mode=display">w^- \leftarrow \tau w + (1-\tau) w^-</script><script type="math/tex; mode=display">\theta^- \leftarrow \tau \theta + (1-\tau) \theta^-</script></li></ul></li></ul><p><strong>总结</strong></p><div class="table-container"><table><thead><tr><th>方法</th><th>策略类型</th><th>更新方式</th><th>核心优势</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>QAC</strong></td><td>随机策略</td><td>在线</td><td>简单直观</td><td>离散动作空间</td></tr><tr><td><strong>A2C</strong></td><td>随机策略</td><td>在线/同步</td><td>低方差，稳定</td><td>并行环境（如A3C）</td></tr><tr><td><strong>Off-Policy AC</strong></td><td>随机策略</td><td>离轨</td><td>数据高效，复用历史数据</td><td>机器人控制</td></tr><tr><td><strong>DPG/DDPG</strong></td><td>确定性策略</td><td>离轨+目标网络</td><td>连续动作空间高效</td><td>物理仿真（如MuJoCo）</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/20/hello-world/"/>
      <url>/2024/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&#x27;[post]&#x27;</span> <span class="string">&quot;title&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数位DP样题</title>
      <link href="/2023/04/01/%E6%95%B0%E4%BD%8DDP%E6%A0%B7%E9%A2%98/"/>
      <url>/2023/04/01/%E6%95%B0%E4%BD%8DDP%E6%A0%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>数位dp的题目一般会问，某个区间内，满足某种性质的数的个数。</p><ol><li>利用前缀和，比如求区间[l,r]中的个数，转化成求[0,r]的个数 [0,l-1]的个数。</li><li>利用树的结构来考虑（按位分类讨论）<br><img src="https://img-blog.csdnimg.cn/d2b3610acb4a4a54ac8786f31fd0e7a4.jpeg" alt="在这里插入图片描述"><br><a href="https://www.luogu.com.cn/problem/P8764">P8764 [蓝桥杯 2021 国 BC] 二进制问题</a></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">70</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        <span class="keyword">if</span>(!j) f[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="keyword">while</span>(n) vec.<span class="built_in">push_back</span>(n%<span class="number">2</span>),n/=<span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=vec.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=vec[i];</span><br><span class="line">        <span class="keyword">if</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">        res+=f[i][k-last];</span><br><span class="line">            last++;</span><br><span class="line">        <span class="keyword">if</span>(last&gt;k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!i&amp;&amp;last==k) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dp</span>(n)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加强一点，处理更多种进制：</p><p><a href="https://www.acwing.com/problem/content/1083/">1081. 度的数量</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],l,r,K,B;</span><br><span class="line"><span class="comment">//预处理组合数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">            <span class="keyword">if</span>(!j) f[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="keyword">while</span>(n) vec.<span class="built_in">push_back</span>(n%B),n/=B;<span class="comment">//十进制转成B进制</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//res记录答案数，last表示用了多少个1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=vec.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=vec[i];<span class="comment">//取出第i位数</span></span><br><span class="line">        <span class="keyword">if</span>(x)<span class="comment">//（如果当前位x==0直接进入右分支，讨论下一位）</span></span><br><span class="line">        &#123;</span><br><span class="line">            res+=f[i][K-last];</span><br><span class="line">            <span class="comment">//当前位填0，从剩下的所有位（共有i位）中选K-last个数。</span></span><br><span class="line">            <span class="comment">//对应于：左分支中0的情况，合法</span></span><br><span class="line">            <span class="keyword">if</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=f[i][K-last<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//x==1，直接讨论下一位，可用的1的个数减1</span></span><br><span class="line">            &#123;</span><br><span class="line">                last++;</span><br><span class="line">                <span class="keyword">if</span>(last&gt;K) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;last==K) res++;<span class="comment">//遍历到最后一位且最后一位取1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r&gt;&gt;K&gt;&gt;B;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dp</span>(r)-<span class="built_in">dp</span>(l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/1084/">1082. 数字游戏</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],l,r;</span><br><span class="line"><span class="comment">//f[i][j]表示一共有i位，且最高位为j的数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++) f[<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=<span class="number">9</span>;k++)</span><br><span class="line">                f[i][j]+=f[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="keyword">while</span>(n) vec.<span class="built_in">push_back</span>(n%<span class="number">10</span>),n/=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//res记录答案数，last表示上一位的数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=vec.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=vec[i];<span class="comment">//取出第i位数</span></span><br><span class="line">        <span class="keyword">if</span>(last&gt;x) <span class="keyword">break</span>;<span class="comment">//这一位数无论怎么取都比上一位小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=last;j&lt;vec[i];j++)<span class="comment">//进入左分支讨论</span></span><br><span class="line">            res+=f[i+<span class="number">1</span>][j];</span><br><span class="line">        last=x;<span class="comment">//更新lat</span></span><br><span class="line">        <span class="keyword">if</span>(!i) res++;<span class="comment">//到了最后一位，剩下一种合法的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;l&gt;&gt;r)</span><br><span class="line">        cout&lt;&lt;<span class="built_in">dp</span>(r)-<span class="built_in">dp</span>(l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/description/1085/">1083. Windy数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],l,r;</span><br><span class="line"><span class="comment">//f[i][j]表示一共有i位，且最高位为j的数的个数</span></span><br><span class="line"><span class="comment">//存的是（包含前导零）的情况</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++) f[<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;k++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(j-k)&gt;=<span class="number">2</span>) f[i][j]+=f[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="keyword">while</span>(n) vec.<span class="built_in">push_back</span>(n%<span class="number">10</span>),n/=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,last=<span class="number">-2</span>;</span><br><span class="line">    <span class="comment">//res记录答案数，last表示上一位的数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=vec.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=vec[i];<span class="comment">//取出第i位数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=(i==vec.<span class="built_in">size</span>()<span class="number">-1</span>);j&lt;x;j++)<span class="comment">//首位不能取到零，其他位可以</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(j-last)&gt;=<span class="number">2</span>) res+=f[i+<span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(x-last)&gt;=<span class="number">2</span>) last=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!i) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">            res+=f[i][j];<span class="comment">//特判首位为零的情况</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dp</span>(r)-<span class="built_in">dp</span>(l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/1086/">1084. 数字游戏 II</a></p><p><code>f[i][j][k]</code> 表示一共有i位，且最高位数字是j，且所有位数字和%P结果为k的数的个数，若要转移到<code>f[i][j][k]</code>的状态，在i-1位对于每个x（x取值0~9）都应使第三维为<code>(k-j)%P</code><br>状态转移方程：<br>$f[i][j][k]=\sum<em>{k=0}^{P-1}\sum</em>{x=0}^{9}f[i-1][x][(k-j)\%P]$</p><p>用last表示到当前为止，前面数位上的数字之和，对此，当前第i位数字为j，前面数字之和为last，那么<br>后i位(包括j这一位)数字之和sum与last的关系就是<br><code>(last+sum)%N==0</code>,那么<code>sum%N==(-last)%N</code>,<br>所以<code>res+=f[i+1][j][(-last%N)]</code>; </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">110</span>],l,r,P;</span><br><span class="line"><span class="comment">//f[i][j][k]表示一共有i位，且最高位数字是j，且所有位数字和%P结果为k的数的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (u%v+v)%v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) f[<span class="number">1</span>][i][i%P]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;P;k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;=<span class="number">9</span>;x++)</span><br><span class="line">                    f[i][j][k]+=f[i<span class="number">-1</span>][x][<span class="built_in">mod</span>(k-j,P)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="keyword">while</span>(n) vec.<span class="built_in">push_back</span>(n%<span class="number">10</span>),n/=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//res记录答案数，last表示前面所有位数上数字的和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=vec.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=vec[i];    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;x;j++)  <span class="comment">//第i位放0~x-1</span></span><br><span class="line">            res+=f[i+<span class="number">1</span>][j][<span class="built_in">mod</span>(-last,P)]; <span class="comment">//0~i位，所以一共有i+1位</span></span><br><span class="line">        last+=x;</span><br><span class="line">        <span class="keyword">if</span>(!i&amp;&amp;last%P==<span class="number">0</span>) res++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;l&gt;&gt;r&gt;&gt;P)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        cout&lt;&lt;<span class="built_in">dp</span>(r)-<span class="built_in">dp</span>(l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/1087/">1085. 不要62</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],l,r;</span><br><span class="line"><span class="comment">//f[i][j]表示一共有i位，且最高位为j的数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++) </span><br><span class="line">        <span class="keyword">if</span>(j!=<span class="number">4</span>) f[<span class="number">1</span>][j]=<span class="number">1</span>；<span class="comment">//一位不含5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">4</span>||(j==<span class="number">6</span>&amp;&amp;k==<span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                f[i][j]+=f[i<span class="number">-1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    <span class="keyword">while</span>(n) vec.<span class="built_in">push_back</span>(n%<span class="number">10</span>),n/=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//res记录答案数，last表示上一位的数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=vec.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=vec[i];<span class="comment">//取出第i位数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;x;j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">4</span>||(j==<span class="number">2</span>&amp;&amp;last==<span class="number">6</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            res+=f[i+<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">4</span>||(x==<span class="number">2</span>&amp;&amp;last==<span class="number">6</span>)) <span class="keyword">break</span>;</span><br><span class="line">        last=x;</span><br><span class="line">        <span class="keyword">if</span>(!i) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;l&gt;&gt;r,l||r)</span><br><span class="line">        cout&lt;&lt;<span class="built_in">dp</span>(r)-<span class="built_in">dp</span>(l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/P8801">P8801 [蓝桥杯 2022 国 B] 最大数字</a></p><p>DFS，两个分支：用A处理/用B处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,ans;</span><br><span class="line"><span class="type">int</span> A,B;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">long</span> <span class="type">long</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;index:&quot;&lt;&lt;index&lt;&lt;&quot; A:&quot;&lt;&lt;a&lt;&lt;&quot; B:&quot;&lt;&lt;b&lt;&lt;&quot; res:&quot;&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(index==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;***&quot;&lt;&lt;endl;</span></span><br><span class="line">    ans=<span class="built_in">max</span>(ans,res);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> x=vec[index];</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">9</span>)</span><br><span class="line">    <span class="built_in">dp</span>(index<span class="number">-1</span>,a,b,res*<span class="number">10</span>+x);</span><br><span class="line">    <span class="keyword">if</span>(a&amp;&amp;x!=<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> pl=<span class="built_in">min</span>(a,<span class="number">9</span>-x);</span><br><span class="line">    <span class="built_in">dp</span>(index<span class="number">-1</span>,a-pl,b,res*<span class="number">10</span>+x+pl);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;=x+<span class="number">1</span>&amp;&amp;x!=<span class="number">9</span>)</span><br><span class="line">    <span class="built_in">dp</span>(index<span class="number">-1</span>,a,b-(x+<span class="number">1</span>),res*<span class="number">10</span>+<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">dp</span>(index<span class="number">-1</span>,a,b,res*<span class="number">10</span>+x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;A&gt;&gt;B;</span><br><span class="line">    <span class="keyword">while</span>(n) vec.<span class="built_in">push_back</span>(n%<span class="number">10</span>),n/=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">dp</span>(vec.<span class="built_in">size</span>()<span class="number">-1</span>,A,B,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P4317">P4317 花神的数论题</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">10000007</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,ans=<span class="number">1</span>,cnt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">70</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][N],num[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        <span class="keyword">if</span>(!j) f[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ksm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base,<span class="type">long</span> <span class="type">long</span> power)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">base%=mod;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(power) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(power&amp;<span class="number">1</span>)</span><br><span class="line">res=res*base%mod;</span><br><span class="line">power&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">base=base*base%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(n) vec.<span class="built_in">push_back</span>(n&amp;<span class="number">1</span>),n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=vec.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=vec[i];</span><br><span class="line"><span class="keyword">if</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">num[cnt+j]+=f[i][j];</span><br><span class="line">++num[++cnt];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">ans*=<span class="built_in">ksm</span>(i+<span class="number">1</span>,num[i+<span class="number">1</span>]),ans%=mod;</span><br><span class="line"><span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;<span class="built_in">dp</span>(n)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P6218">P6218 [USACO06NOV] Round Numbers S</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="comment">//预处理组合数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        <span class="keyword">if</span>(!j) f[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    <span class="keyword">while</span>(x) num.<span class="built_in">push_back</span>(x%<span class="number">2</span>),x/=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n=num.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>, last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">max</span>((n+<span class="number">1</span>)/<span class="number">2</span>-(last+<span class="number">1</span>),<span class="number">0</span>);j&lt;=i;j++) res+=f[i][j];</span><br><span class="line">        <span class="keyword">else</span> last++;</span><br><span class="line">        <span class="keyword">if</span>(!i&amp;&amp;last&gt;=(n+<span class="number">1</span>)/<span class="number">2</span>) res++;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=(i+<span class="number">1</span>)/<span class="number">2</span>;j&lt;i;j++)</span><br><span class="line">            res+=f[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">cout&lt;&lt;<span class="built_in">get</span>(r)-<span class="built_in">get</span>(l<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010] 数字计数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL f[<span class="number">20</span>],cnta[<span class="number">20</span>],cntb[<span class="number">20</span>],ten[<span class="number">20</span>],l,r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> *cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) num[++len]=x%<span class="number">10</span>,x=x/<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">        cnt[j]+=f[i<span class="number">-1</span>]*num[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num[i];j++)</span><br><span class="line">        cnt[j]+=ten[i<span class="number">-1</span>];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            num2=num2*<span class="number">10</span>+num[j];</span><br><span class="line">        cnt[num[i]]+=num2+<span class="number">1</span>;</span><br><span class="line">        cnt[<span class="number">0</span>]-=ten[i<span class="number">-1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">ten[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]*<span class="number">10</span>+ten[i<span class="number">-1</span>];</span><br><span class="line">        ten[i]=<span class="number">10</span>*ten[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(l<span class="number">-1</span>,cnta);</span><br><span class="line">    <span class="built_in">solve</span>(r,cntb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    cout&lt;&lt;cntb[i]-cnta[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 数位DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奎恩－麦克拉斯基化简法 (Q-M 法）化简逻辑代数式</title>
      <link href="/2023/04/01/%E5%A5%8E%E6%81%A9%EF%BC%8D%E9%BA%A6%E5%85%8B%E6%8B%89%E6%96%AF%E5%9F%BA%E5%8C%96%E7%AE%80%E6%B3%95-Q-M-%E6%B3%95%EF%BC%89%E5%8C%96%E7%AE%80%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%BC%8F/"/>
      <url>/2023/04/01/%E5%A5%8E%E6%81%A9%EF%BC%8D%E9%BA%A6%E5%85%8B%E6%8B%89%E6%96%AF%E5%9F%BA%E5%8C%96%E7%AE%80%E6%B3%95-Q-M-%E6%B3%95%EF%BC%89%E5%8C%96%E7%AE%80%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B0%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>《数字电子技术基础（第6版）》（阎石）<br><img src="https://img-blog.csdnimg.cn/55e0fe4d383744a9b56625a47f499754.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/437a9e09d4164439805ddc42fa1a7c61.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/80ab3f7501fe43f693a4c581972bf51c.png" alt="在这里插入图片描述"><br>极度暴力的模拟实现，不保熟的代码QAQ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec[<span class="number">11</span>],temp;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>],head[<span class="number">11</span>],tail[<span class="number">11</span>],flag[<span class="number">1050</span>];</span><br><span class="line"><span class="type">int</span> box[<span class="number">1050</span>][<span class="number">100</span>],ans[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">1050</span>][<span class="number">11</span>],now,last,q;</span><br><span class="line"><span class="type">int</span> ed[<span class="number">100</span>],minn=<span class="number">0x3f3f3f</span>,b[<span class="number">100</span>],vis[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;minn) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=ans[i][<span class="number">0</span>];j++)</span><br><span class="line">ed[ans[i][j]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ok=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!ed[a[i]])</span><br><span class="line">&#123;</span><br><span class="line">ok=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ok)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">q=<span class="number">0</span>;</span><br><span class="line">minn=<span class="built_in">min</span>(minn,sum);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i])</span><br><span class="line">&#123;</span><br><span class="line">b[++q]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(ed,<span class="number">0</span>,<span class="built_in">sizeof</span>(ed));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>,sum+<span class="number">1</span>);</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>,sum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>,pos=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;n;t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num[x][t]==<span class="number">-1</span>&amp;&amp;num[y][t]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(num[x][t]==<span class="number">-1</span>||num[y][t]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(num[x][t]^num[y][t])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!cnt) pos=t,cnt++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入变量数目：&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入最小项数目：&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请依次输入最小项序号：&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">now=m,last=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//计算每个最小项中1的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=a[i],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(t)</span><br><span class="line">&#123;</span><br><span class="line">cnt+=(t%<span class="number">2</span>);</span><br><span class="line">num[i][j++]=t%<span class="number">2</span>;</span><br><span class="line">t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec[cnt].<span class="built_in">push_back</span>(i);</span><br><span class="line">box[i][++box[i][<span class="number">0</span>]]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for(int i=0;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">tail[i]=vec[i].size();</span></span><br><span class="line"><span class="comment">cout&lt;&lt;&quot;vec[&quot;&lt;&lt;i&lt;&lt;&quot;]:&quot;;</span></span><br><span class="line"><span class="comment">for(int j=0;j&lt;vec[i].size();j++)</span></span><br><span class="line"><span class="comment">cout&lt;&lt;a[vec[i][j]]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> T=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//合并最小项</span></span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=head[i];j&lt;tail[i];j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=head[i+<span class="number">1</span>];k&lt;tail[i+<span class="number">1</span>];k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pos=<span class="built_in">check</span>(vec[i][j],vec[i+<span class="number">1</span>][k]);</span><br><span class="line">&#123;</span><br><span class="line">flag[vec[i][j]]=<span class="number">1</span>,flag[vec[i+<span class="number">1</span>][k]]=<span class="number">1</span>;</span><br><span class="line">++now;</span><br><span class="line">a[now]=a[vec[i][j]];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=n;t++)</span><br><span class="line">num[now][t]=num[vec[i][j]][t];</span><br><span class="line">num[now][pos]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=box[vec[i][j]][<span class="number">0</span>];t++)</span><br><span class="line">box[now][++box[now][<span class="number">0</span>]]=box[vec[i][j]][t];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=box[vec[i+<span class="number">1</span>][k]][<span class="number">0</span>];t++)</span><br><span class="line">box[now][++box[now][<span class="number">0</span>]]=box[vec[i+<span class="number">1</span>][k]][t];</span><br><span class="line">vec[i].<span class="built_in">push_back</span>(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">head[i]=tail[i],tail[i]=vec[i].<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=now;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag[i])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;P&#x27;</span>&lt;&lt;++cnt&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; 字母组合：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i][j]==<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;num[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl&lt;&lt;<span class="string">&quot; 包含的最小项:&quot;</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=box[i][<span class="number">0</span>];j++)</span><br><span class="line">cout&lt;&lt;box[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>,ans[cnt][j]=box[i][j];</span><br><span class="line">ans[cnt][<span class="number">0</span>]=box[i][<span class="number">0</span>];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//求最小覆盖</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;最小项个数:&quot;</span>&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;最小项组成：&quot;</span> ; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;P&quot;</span>&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//11</span></span><br><span class="line"><span class="comment">//0 2 3 8 10 14 15 22 24 27 31</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数电 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT求多项式乘积</title>
      <link href="/2022/12/28/FFT%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E7%A7%AF-1/"/>
      <url>/2022/12/28/FFT%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B9%98%E7%A7%AF-1/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>之前在b站上看到了一些介绍FFT的视频:</p><p><a href="https://www.bilibili.com/video/BV1za411F76U/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">《快速傅里叶变换(FFT)——有史以来最巧妙的算法？》</a></p><p><a href="https://www.bilibili.com/video/BV1CY411R7bA/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3958408d1c03c5f949f79567e56c15f2">《这个算法改变了世界》 </a></p><p>于是打算写一篇记录一下qwq（本博客中的截图基本上来源于第一个视频）</p><p><strong>Fast Fourier Transform</strong> 是一种能在$O(nlogn)$的时间内将一个用系数表示的多项式转化成点值表示。</p><p>$P(x)=p_0+p_1x+p_2x^2+…+p_dx^d$</p><blockquote><p>系数表示法：$[p_0,p_1,p_2,…,p_d]$</p><p>点值表示法：${(x_0,P(x_0),(x_1,P(x_1),…,(x_d,P(x_d))}$</p><p>(n+1个不同点可以确定一个n次的多项式：可以用矩阵列式求解）</p></blockquote><p>当我们试图算两个多项式相乘的结果：</p><p>$A(x)=a_0+a_1x+…+a_dx^d$</p><p>$B(x)=b_0+b_1x+…+b_dx^d$</p><p>传统的做法需要$O(n^2)$，而如果我们先求出若干个点的坐标（多少个点根据最后算出的会是几次多项式而定，比如A是三次多项式，B是五次多项式，算出来的C会是八次多项式，那么就需要找九个点），最后再根据这些点把多项式还原成系数表示，但是对于每个点，知道一个横坐标，需要(d+1)次计算才能知道这个点的纵坐标，总复杂度还是会达到$O(n^2)$，达咩。</p><p><img src="https://img-blog.csdnimg.cn/28c8c643e2be45f5924deb2882f647c6.jpeg" alt="主要过程"></p><p>可不可以通过选取一些巧妙的点来减少我们的计算次数？<br><img src="https://img-blog.csdnimg.cn/7e03cb2422c74d43861c1e9b32dd9562.jpeg" alt="划分"><br>我们可以每次将多项式分成奇项和偶项，通过这样的划分可以便捷地算出横坐标互为相反数的一对点对的坐标，此时我们需要求出$x^2$分别代入$P_e(x^2)$和$P_o(x^2)$算出来的值，原问题变成了两个子问题，每个子问题的次数是原问题的$1/2$。我们想着能不能一直这么递归下去，直到分到底层（次数为1），再自底向上，层层归并求出答案？<br><img src="https://img-blog.csdnimg.cn/510027d66d1f43069ff767f65da41dc9.jpeg" alt="递归"><br>实际上在递归步骤，我们假设了每个多项式我们都使用相反数对来求值，然而对两个子问题而言，每个求值点都是平方数，没办法继续了（悲.jpg）于是我们希望把新的求值点也弄成相反数对QAQ</p><div class="tip warning faa-horizontal animated"><p>为了方便讨论，下文的n均为2的整数次幂，如果题目的n不是2的整数次幂，我们可以加一波操作~</p></div><p>于是——复数大法好！</p><h1 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h1><p><img src="https://img-blog.csdnimg.cn/ca45543afd184cbfbbf40ffca5626a54.jpeg" alt="四次方根"><br>按照上面的逻辑推演，再向下递归一层我们需要两个相反点对，即要求出$x^4=1$的四个解；<br><img src="https://img-blog.csdnimg.cn/09106adb06a64dc3b5999ba0e43a93d2.jpeg" alt="八次方根"><br>再向下递归一层我们需要四个相反点对，即要求出$x^8=1$的八个解；<br>现在推广到d阶多项式，我们要先取n&gt;d个点，（并且n等于2的整数次幂），我们为求解多项式乘积所选取的点就是1的n个n次方根。<br><img src="https://img-blog.csdnimg.cn/d04f1fde8341422390d89a5f8bd74736.jpeg" alt="单位根"><br><img src="https://img-blog.csdnimg.cn/bc9a5f61bbda41eba5c0417d21071a73.jpeg" alt="在这里插入图片描述"></p><blockquote><p><strong>单位根的性质：</strong></p><p> <strong>性质一：$ω^{2k}_{2n}=ω^{k}_n$</strong></p><p> <strong>性质二：$ω^{k+n/2}_n=−ω^k_n$</strong>（对应的点关于原点对称）</p></blockquote><h1 id="快速傅里叶变换的数学证明"><a href="#快速傅里叶变换的数学证明" class="headerlink" title="快速傅里叶变换的数学证明"></a>快速傅里叶变换的数学证明</h1><p> 设$A(x) = a<em>0 + a_1x + a_2x^2 +…+a</em>{n-1}x^{n-1}$，为求离散傅里叶变换，要把一个$x = \omega_n^k$代入。</p><p> 考虑将$A(x)$的每一项按照下标的奇偶分成两部分：</p><p>$A(x) = (a<em>0 + a_2x^2 + … + a</em>{n - 2}x^{n - 2}) + (a<em>1x + a_3x^3 + … + a</em>{n-1}x^{n-1})$</p><p>设两个多项式：<br>$A<em>1(x) = a_0 + a_2x + … + a</em>{n - 2}x^{\frac{n}{2} - 1}$</p><p>$A<em>2(x) = a_1 + a_3x + … + a</em>{n - 1}x^{\frac{n}{2} - 1}$</p><p>则：$A(x) = A_1(x^2) + xA_2(x^2)$</p><p>假设$k &lt; \frac{n}{2}$，现要把$x = \omega_n^k$代入，</p><script type="math/tex; mode=display">\begin{align*}A(\omega_n^k) &= A_1(\omega_n^{2k}) + \omega_n^kA_2(\omega_n^{2k}) \\&= A_1(\omega_{\frac{n}{2}}^{k}) + \omega_n^kA_2(\omega_{\frac{n}{2}}^{k})\end{align*}</script><p>那么对于$A(\omega_n^{k + \frac{n}{2}})$:</p><script type="math/tex; mode=display">\begin{align*}A(\omega_n^{k + \frac{n}{2}}) &= A_1(\omega_n^{2k + n}) + \omega_n^{k + \frac{n}{2}}A_2(\omega_n^{2k + n}) \\&= A_1(\omega_{\frac{n}{2}}^{k} \times \omega_n^n) + \omega_n^{k + \frac{n}{2}} A_2(\omega_{\frac{n}{2}}^{k} \times \omega_n^n) \\&= A_1(\omega_{\frac{n}{2}}^{k}) - \omega_n^kA_2(\omega_{\frac{n}{2}}^{k})\end{align*}</script><p>所以，如果我们知道两个多项式$A<em>1(x)$和$A_2(x)$分别在$(\omega</em>{\frac{n}{2}}^{0}, \omega<em>{\frac{n}{2}}^{1}, \omega</em>{\frac{n}{2}}^{2}, … , \omega_{\frac{n}{2}}^{\frac{n}{2} - 1})$的值，就可以求出$A(x)$在$\omega_n^0, \omega_n^1, \omega_n^2, …, \omega_n^{n-1}$处的值了，$A_1(x)$和$A_2(x)$是规模缩小一半的子问题，分治边界$n=1$.<br><img src="https://img-blog.csdnimg.cn/e9313720c8584a178e6f368f359195f1.jpeg" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3e5c8acb45d14468bcdbe20689b0becf.jpeg" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bdfa0080d16b4896a5fdcbb8319d62e3.jpeg" alt="在这里插入图片描述"></p><h1 id="IFFT"><a href="#IFFT" class="headerlink" title="IFFT"></a>IFFT</h1><p>现在我们有了这若干个点的纵坐标，问题来到如何根据这些点的坐标还原答案多项式的系数，这需要用到<strong>IFFT(Inverse Fast Fourier Transform)</strong></p><p><strong>结论：把多项式$A(x)$的离散傅里叶变换结果作为另一个多项式$B(x)$的系数，取单位根的倒数即$\omega<em>{n}^{0}, \omega</em>{n}^{-1}, \omega<em>{n}^{-2}, …, \omega</em>{n}^{-(n - 1)}$作为$x$代入$B(x)$，得到的每个数再除以$n$，得到的是$A(x)$的各项系数。</strong><br>（FFT的过程是求y矩阵，IFFT的过程是反过来求a矩阵，求出$\omega$矩阵的逆矩阵即可）<br><img src="https://img-blog.csdnimg.cn/d2dcb0e5e448489dba496a0150227b5d.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a86b042decab40b781cf34369f61731d.jpeg" alt="在这里插入图片描述"></p><h1 id="朴素版FFT函数代码"><a href="#朴素版FFT函数代码" class="headerlink" title="朴素版FFT函数代码"></a>朴素版FFT函数代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; a[N],b[N];</span><br><span class="line">ll n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) tmp=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(complex&lt;<span class="type">double</span>&gt; *a,ll n,ll op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span>;</span><br><span class="line">    complex&lt;<span class="type">double</span>&gt; a0[n],a1[n];</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">        a0[i]=a[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">        a1[i]=a[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fft</span>(a0,n&gt;&gt;<span class="number">1</span>,op); <span class="built_in">fft</span>(a1,n&gt;&gt;<span class="number">1</span>,op);</span><br><span class="line">    <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">W</span><span class="params">(cos(pi/n),sin(pi/n)*op)</span>,<span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++,w*=W)</span><br><span class="line">&#123;</span><br><span class="line">        a[i]=a0[i]+w*a1[i];</span><br><span class="line">        a[i+n]=a0[i]-w*a1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;=n; i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;=m; i++) b[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(m+=n,n=<span class="number">1</span>; n&lt;=m; n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fft</span>(a,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">fft</span>(b,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) a[i]*=b[i];</span><br><span class="line">    <span class="built_in">fft</span>(a,n&gt;&gt;<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">&quot;%.0lf &quot;</span>,<span class="built_in">fabs</span>(a[i].<span class="built_in">real</span>()/n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="优化FFT"><a href="#优化FFT" class="headerlink" title="优化FFT"></a>优化FFT</h1><blockquote><p>在进行FFT时，我们要把各个系数不断分组并放到两侧，那么一个系数原来的位置和最终的位置有什么规律呢？</p><p>初始位置：0 1 2 3 4 5 6 7 </p><p>第一轮后：0 2 4 6|1 3 5 7 </p><p>第二轮后：0 4|2 6|1 5|3 7</p><p>第三轮后：0|4|2|6|1|5|3|7</p><p>“|”代表分组界限。一个位置a上的数，最后所在的位置是“a二进制翻转得到的数”，例如6(011)最后到了3(110)，1(001)最后到了4(100)。</p><p>那么我们可以据此写出非递归版本FFT：先把每个数放到最后的位置上，然后不断向上还原，同时求出点值表示。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(cp *a,<span class="type">int</span> n,<span class="type">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> bit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n) bit++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(bit<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i]) <span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;n;len*=<span class="number">2</span>)<span class="comment">//len是准备合并序列的长度的二分之一</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="function">cp <span class="title">temp</span><span class="params">(cos(pi/len),inv*sin(pi/len))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=len*<span class="number">2</span>)<span class="comment">//len*2是准备合并序列的长度，i是合并到了哪一位</span></span><br><span class="line">&#123;</span><br><span class="line">            <span class="function">cp <span class="title">omega</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++,omega*=temp)<span class="comment">//只扫左半部分，得到右半部分的答案</span></span><br><span class="line">            &#123;</span><br><span class="line">                cp x=a[i+j],y=omega*a[i+j+len];</span><br><span class="line">                a[i+j]=x+y,a[i+j+mid]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll N=<span class="number">10000010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll n,m,limit;</span><br><span class="line">complex&lt;<span class="type">double</span>&gt; a[N],b[N];</span><br><span class="line">ll c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) tmp=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x=-x;</span><br><span class="line">    ll y=<span class="number">10</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y&lt;=x) y=(y&lt;&lt;<span class="number">3</span>)+(y&lt;&lt;<span class="number">1</span>), len++;</span><br><span class="line">    <span class="keyword">while</span>(len--) y/=<span class="number">10</span>, <span class="built_in">putchar</span>(x/y+<span class="number">48</span>),x%=y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(complex&lt;<span class="type">double</span>&gt; *a,ll op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;limit; i++)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;c[i]) <span class="built_in">swap</span>(a[i],a[c[i]]);</span><br><span class="line">    <span class="keyword">for</span>(ll mid=<span class="number">1</span>; mid&lt;limit; mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">W</span><span class="params">(cos(pi/mid),op*sin(pi/mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(ll r=mid&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>; j&lt;limit; j+=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">complex&lt;<span class="type">double</span>&gt; <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(ll l=<span class="number">0</span>; l&lt;mid; l++,w*=W)</span><br><span class="line">            &#123;</span><br><span class="line">                complex&lt;<span class="type">double</span>&gt; x=a[j+l],y=w*a[j+mid+l];</span><br><span class="line">                a[j+l]=x+y; a[j+mid+l]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;=n; i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;=m; i++) b[i]=<span class="built_in">read</span>();</span><br><span class="line">    limit=<span class="number">1</span>; ll l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(limit&lt;=n+m)</span><br><span class="line"> limit&lt;&lt;=<span class="number">1</span>,l++;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;limit i++) </span><br><span class="line">    c[i]=(c[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">FFT</span>(a,<span class="number">1</span>); <span class="built_in">FFT</span>(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;=limit; i++) a[i]*=b[i];</span><br><span class="line">    <span class="built_in">FFT</span>(a,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;=n+m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(a[i].<span class="built_in">real</span>()/limit+<span class="number">0.5</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p>参考资料：</p><p> <a href="https://www.cnblogs.com/RabbitHu/p/FFT.html">小学生都能看懂的FFT！！！ </a></p><p><a href="https://www.bilibili.com/video/BV1za411F76U/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">《快速傅里叶变换(FFT)——有史以来最巧妙的算法？》</a></p><p><a href="https://blog.csdn.net/enjoy_pascal/article/details/81478582?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167209928316782425184114%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167209928316782425184114&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81478582-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_control1&amp;utm_term=FFT&amp;spm=1018.2226.3001.4187">十分简明易懂的FFT（快速傅里叶变换）</a></p><p><a href="https://www.luogu.com.cn/blog/xukuan/fast-fast-tle">多项式FFT</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数论 </category>
          
          <category> FFT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English composition notes</title>
      <link href="/2022/12/16/English-composition-notes/"/>
      <url>/2022/12/16/English-composition-notes/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/英语笔记.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Course Review</title>
      <link href="/2022/12/04/Course-Review/"/>
      <url>/2022/12/04/Course-Review/</url>
      
        <content type="html"><![CDATA[<p>Through this semester’s study, I understand the basic framework of a paper, which generally includes title, abstract, introduction, literature review, experiment/method, results, discussion, conclusion, references and appendix.</p><ul><li>The <strong>title</strong> of the paper seeks to be concise, accurate, which can reflect the core theme of the paper.</li><li>The <strong>abstract</strong> is a short article with complete logic. It should briefly introduce the whole paper’s aim, process, method, research result, and conclusion. The purpose of writing the abstract is to enable the reviewer to have a general understanding of the main content of the paper before reviewing the complete text, and to enable the reader to have a general account of the problem studied by the author through reading it, and to decide whether to read the full text further.</li><li>The <strong>literature review</strong> is based on the reading, selection, comparison, classification, analysis, and synthesis of the literature, an intelligence study in which researchers use their own language to give a comprehensive account of the state of a problem. The main contents of the literature review include the history of the research, the analysis of the research methods, the solved problems along with the remaining problems. This will not only enable researchers to determine the direction of research but also facilitate others to understand the starting point and cut-in point of the study. On top of that, it can highlight the contribution and innovation of the author.</li><li>In the <strong>“Experiment”</strong> part, the material property, quality, source, material selection, and treatment should be described in detail, so as to help the peer to repeat the experiment, to verify the results of the paper. The author should explain the procedure of the experiment, the time, place, method of the experiment, and the normal or abnormal phenomena and problems in the course of the experiment.</li><li>The <strong>“Results”</strong> section is a systematic summary of the experiment, showing the reader the information most relevant to the subject of the survey, with non-textual elements (such as graphs) appropriately used to present the results more effectively.</li><li><strong>Discussion</strong>: summarize the current research, clarify the relationship between the results of this study and previous literature, discuss unexpected or unexpected findings, describe the relationship between the results of this study and relevant theoretical models.</li><li>The <strong>conclusion</strong> part is to summarize the content and results of the paper, propose the shortcomings that can be improved and the direction that can be improved or further studied in the future.</li><li><strong>References</strong> are written to respect and protect the intellectual property rights of the original authors and to facilitate access to relevant information. It should be noted that there are certain format specifications for writing references.</li></ul><hr><p>Through the demonstration of Ms. Xue in class, I knew some literature retrieval websites that I didn’t know before and mastered the relevant retrieval methods. Furthermore, I knew how to evaluate various sources(3 principles: <strong>review, recent, and relevant</strong>).</p><blockquote><p><a href="https://www.cnki.net/">中国知网CNKI</a></p><p><a href="https://ieeexplore.ieee.org/Xplore/home.jsp">IEEE</a></p><p><a href="https://www.webofscience.com/wos/woscc/basic-search">Web of Science</a></p><p><a href="https://link.springer.com/chapter/10.1007/978-1-349-22021-2_9">Springer Link</a></p><p><a href="https://www.sciencedirect.com/">Scirnce Direct</a></p></blockquote><hr><p>I have mastered some reading strategies, learned to use intensive reading to understand the details of academic papers, read the abstract to understand the outline of the paper, and through key sentences to quickly get to the core of the paragraph. With the help of Ms. Xue, my critical thinking skills have enhanced, which laid the foundation for future study and paper writing. </p><p>​                                                                        </p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图的判定及最大匹配</title>
      <link href="/2022/11/24/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E5%8F%8A%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/"/>
      <url>/2022/11/24/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A%E5%8F%8A%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>如果一张无向图的N个结点可以分成A,B两个非空集合，其中$A\cap B=\emptyset$，并且在同一集合内的点之间都没有边相连，则称这张图为二分图。</p><h1 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h1><p><strong>定理：一张图是二分图，当且仅当图中不存在奇环（长度为奇数的环）。</strong></p><p><a href="https://www.luogu.com.cn/problem/P1330">P1330 封锁阳光大学</a></p><p>染色法判定：尝试用黑白两色标记，当一个结点被标记后，它的所有相邻结点应该被标记与之相反的颜色，若该标记过程中出现冲突，则说明图中存在奇环。</p><p>下用BFS、DFS、并查集分别实现。</p><p>BFS<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N],ver[M],nex[M],vis[N];</span><br><span class="line"><span class="type">int</span> n,m,u,v,tot=<span class="number">0</span>,ok=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> sum[<span class="number">5</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ver[++tot]=v;</span><br><span class="line">nex[tot]=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">vis[start]=color;</span><br><span class="line"><span class="comment">//printf(&quot;vis[%d]=%d\n&quot;,start,vis[start]);</span></span><br><span class="line">sum[<span class="number">1</span>]=<span class="number">1</span>,sum[<span class="number">2</span>]=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=nex[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> to=ver[i];</span><br><span class="line"><span class="keyword">if</span>(vis[to]==<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[now]==<span class="number">1</span>) vis[to]=<span class="number">2</span>,sum[<span class="number">2</span>]++;</span><br><span class="line"><span class="keyword">else</span> vis[to]=<span class="number">1</span>,sum[<span class="number">1</span>]++;</span><br><span class="line"><span class="comment">//printf(&quot;vis[%d]=%d\n&quot;,to,vis[to]);</span></span><br><span class="line">q.<span class="built_in">push</span>(to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[to]==vis[now]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;<span class="comment">//vis[i]==0的话表明跟之前的结点都不连通 </span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">bfs</span>(i,<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">ok=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ans+=<span class="built_in">min</span>(sum[<span class="number">1</span>],sum[<span class="number">2</span>]);<span class="comment">//加和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ok) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>DFS<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> head[N],ver[M],nex[M],vis[N];</span><br><span class="line"><span class="type">int</span> n,m,u,v,tot=<span class="number">0</span>,ok=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> sum[<span class="number">5</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ver[++tot]=v;</span><br><span class="line">nex[tot]=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=nex[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> to=ver[i];</span><br><span class="line"><span class="keyword">if</span>(!vis[to]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[now]==<span class="number">1</span>) vis[to]=<span class="number">2</span>,sum[<span class="number">2</span>]++;</span><br><span class="line"><span class="keyword">else</span> vis[to]=<span class="number">1</span>,sum[<span class="number">1</span>]++;</span><br><span class="line"><span class="built_in">dfs</span>(to,vis[to]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[to]==vis[now]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;<span class="comment">//vis[i]==0的话表明跟之前的结点都不连通 </span></span><br><span class="line">sum[<span class="number">1</span>]=<span class="number">1</span>,sum[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">ok=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ans+=<span class="built_in">min</span>(sum[<span class="number">1</span>],sum[<span class="number">2</span>]);<span class="comment">//加和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ok) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>并查集二分图的判定（“扩展域”的并查集）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>],size[N];</span><br><span class="line"><span class="type">int</span> n,m,x,y,tot=<span class="number">0</span>,ok=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> f[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">f[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="type">int</span> fx1=<span class="built_in">find</span>(x),fy1=<span class="built_in">find</span>(y);</span><br><span class="line"><span class="type">int</span> fx2=<span class="built_in">find</span>(x+n),fy2=<span class="built_in">find</span>(y+n);</span><br><span class="line"><span class="keyword">if</span>(fx1==fy1)</span><br><span class="line">&#123;</span><br><span class="line">ok=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> f[fx2]=fy1,f[fy2]=fx1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ok) cout&lt;&lt;<span class="string">&quot;OK&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>],size[N*<span class="number">2</span>],mem[N*<span class="number">2</span>],h[N];</span><br><span class="line"><span class="comment">//1~n白染色域，n+1~2n黑染色域 </span></span><br><span class="line"><span class="type">int</span> n,m,x,y,tot=<span class="number">0</span>,ok=<span class="number">1</span>,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> f[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(fx!=y)</span><br><span class="line">    &#123;</span><br><span class="line">        f[y]=fx;</span><br><span class="line">        size[fx]+=size[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">f[i]=i,size[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="comment">//每条边的两个顶点必不在一个染色域 </span></span><br><span class="line"><span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(fx==fy)<span class="comment">//在同一个染色域 </span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(h[x]) <span class="built_in">merge</span>(h[x],fy);</span><br><span class="line"><span class="keyword">if</span>(h[y]) <span class="built_in">merge</span>(h[y],fx);</span><br><span class="line">h[x]=fy,h[y]=fx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> q=<span class="built_in">find</span>(i);</span><br><span class="line"><span class="keyword">if</span>(!mem[q])<span class="comment">//一个未处理过的并查集 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p=<span class="built_in">find</span>(h[i]);</span><br><span class="line">mem[p]=mem[q]=<span class="number">1</span>;</span><br><span class="line">ans+=<span class="built_in">min</span>(size[p],size[q]);<span class="comment">//两域取其小 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><p>匈牙利算法（增广路算法）：</p><p><a href="https://www.luogu.com.cn/problem/P3386">P3386 【模板】二分图最大匹配</a></p><p>尝试给每个左部结点x匹配一个右部结点y。y能与x匹配的条件：</p><ol><li>y本身就是非匹配点；</li><li>y已经与x’匹配，但从x’出发能找到另一个y’与x’匹配。</li></ol><p>特点：当一个结点成为匹配点之后，至多因为找到增广路而更换匹配对象，但是不会变回非匹配点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> n,m,e,tot,ans;</span><br><span class="line"><span class="type">int</span> mp[N][N],vis[N],match[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!mp[x][i]||vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!match[i]||<span class="built_in">dfs</span>(match[i]))</span><br><span class="line">&#123;</span><br><span class="line">match[i]=x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;e;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=e;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">mp[x][y]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论 </category>
          
          <category> 二分图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIS LCS LCIS相关问题</title>
      <link href="/2022/11/18/LIS-LCS-LCIS%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/18/LIS-LCS-LCIS%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/ef6842e666034073a032d1ab5a1440c6.jpeg" alt="线性DP基础问题"></p><h1 id="P1020-NOIP1999-普及组-导弹拦截"><a href="#P1020-NOIP1999-普及组-导弹拦截" class="headerlink" title="P1020 [NOIP1999 普及组] 导弹拦截"></a>P1020 [NOIP1999 普及组] 导弹拦截</h1><p><a href="https://www.luogu.com.cn/problem/P1020">P1020 [NOIP1999 普及组] 导弹拦截</a></p><p>导弹拦截应该是接触DP的第一题（只不过洛谷上的数据加强了，按照上图的$O(N^2)$做法过不去QAQ可以改用二分。</p><p> <strong>Dilworth定理：偏序集能划分成的最少的全序集个数等于最大反链的元素个数</strong></p><p>把一个数列划分成最少的最长不升子序列的数目就等于这个数列的最长上升子序列的长度（LIS)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>],LDS[<span class="number">100010</span>],LIS[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x,i=<span class="number">0</span>,len=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x))</span><br><span class="line">a[i++]=x;</span><br><span class="line">LDS[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;=LDS[len<span class="number">-1</span>])</span><br><span class="line">LDS[len++]=a[j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=len;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;LDS[mid]) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LDS[l]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    LIS[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> len2=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;LIS[len2<span class="number">-1</span>])</span><br><span class="line">LIS[len2++]=a[j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=len2;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;=LIS[mid]) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LIS[l]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;len2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1439-【模板】最长公共子序列"><a href="#P1439-【模板】最长公共子序列" class="headerlink" title="P1439 【模板】最长公共子序列"></a>P1439 【模板】最长公共子序列</h1><p><a href="https://www.luogu.com.cn/problem/P1439">P1439 【模板】最长公共子序列</a></p><p>也不给你用上图的朴素DP过去($O(N^2)$）www</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">     &#123;</span><br><span class="line">     dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">     <span class="keyword">if</span>(a1[i]==a2[j])</span><br><span class="line">     dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   cout&lt;&lt;dp[n][m];</span><br></pre></td></tr></table></figure><p>但本题数据有个明显的特征即两个序列都是全排列，也就是说我们可以重新构造一种映射关系。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>],b[<span class="number">100010</span>],LIS[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,i;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="comment">//由于a b 中元素完全相同，只是顺序不同，可以利用映射关系，将a映射成一个单调递增序列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">a[x]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相应地，由a给出的映射关系，可将b构造成一个新的序列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">b[i]=a[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个序列的子序列，一定是a的子序列。而a本身就是单调递增的。因此这个子序列是单调递增的。</span></span><br><span class="line"><span class="comment">//换句话说，只要这个子序列在b中单调递增，它就是a的子序列</span></span><br><span class="line">    <span class="comment">//哪个最长呢？当然是b的LIS最长。下用二分+贪心求b的LIS即可 </span></span><br><span class="line">LIS[<span class="number">1</span>]=b[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len2=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[j]&gt;LIS[len2])</span><br><span class="line">LIS[++len2]=b[j];<span class="comment">//如果此时检索到的数比LIS的最后一个数（也即最大的数）大，直接插到LIS尾部 </span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则，在LIS前面的数中二分查找合适的位置进行替换 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=len2;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(b[j]&lt;=LIS[mid]) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LIS[l]=b[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;len2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="P1637-三元上升子序列"><a href="#P1637-三元上升子序列" class="headerlink" title="P1637 三元上升子序列"></a>P1637 三元上升子序列</h1><p><a href="https://www.luogu.com.cn/problem/P1637">P1637 三元上升子序列</a><br><a href="https://www.luogu.com.cn/problem/UVA12983">UVA12983 The Battle of Chibi</a></p><p>给定一个长度为n的序列，求其包含的m元单调上升子序列个数。<br>见求LIS思DP。导弹拦截那种题，开f[结尾编号]=序列长度，信息量不够，考虑定义f[序列长度][结尾编号] =序列个数。</p><p>状态转移：$f[i][j]=\sum f[i-1][k],1&lt;=k&lt;j,a[k]&lt;a[i]$</p><p>这样做的时间复杂度为$O(n^2*m)$</p><p>得想办法在更短时间内统计出$\sum f[i-1][k]$,树状数组或者线段树都可以实现在$O(log n)$内的区间统计。</p><p>先离散化，将a[]的分布集中起来，以a[k]为下标储存f[i-1][k]的值。</p><p>此时针对状态转移方程写两层循环：外层循环枚举长度，每次枚举到一个长度都重置一下树状数组c[]。{内层枚举序列结尾坐标，此前已将f[i-1][k]增加到树状数组中，此时只需用树状数求和即可。然后把f[i-1][j]加到树状数组中，这个值只会更新到比a[j]大的数（对应状态转移方程里的a[k]&lt;a[i]），这些数后续会被调用（对应状态转移方程里的1&lt;=k&lt;j）}。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30010</span>;</span><br><span class="line">ll n,f[<span class="number">4</span>][N],a[N],b[N],c[N],ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lowbit</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll p,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]+=v;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">sum+=c[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>,a[i])-b;<span class="comment">//二分查找在数组中的位置</span></span><br><span class="line">f[<span class="number">1</span>][i]=<span class="number">1</span>;<span class="comment">//初始化：长度唯一，本身为结尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//离散化结束，初始化结束，准备工作完成</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">3</span>;i++)<span class="comment">//枚举长度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));<span class="comment">//重置树状数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=<span class="built_in">ask</span>(a[j]<span class="number">-1</span>);<span class="comment">//求和</span></span><br><span class="line"><span class="built_in">update</span>(a[j],f[i<span class="number">-1</span>][j]);<span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">ans+=f[<span class="number">3</span>][i];</span><br><span class="line">cout&lt;&lt;ans; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="272-最长公共上升子序列"><a href="#272-最长公共上升子序列" class="headerlink" title="272. 最长公共上升子序列"></a>272. 最长公共上升子序列</h1><p><a href="https://www.acwing.com/problem/content/description/274/">272. 最长公共上升子序列</a></p><p>是LIS和LCS的结合体，可以尝试用a解决公共子序列问题，用b解决上升子序列问题。<br>定义$f[i][j]$:$a[1]-a[i],b[1]-b[j]$可以构成的以$b[j]$结尾的LCIS的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(A[i]==B[j]) F[i,j]=F[i<span class="number">-1</span>,j];</span><br><span class="line"><span class="keyword">if</span>(A[i]!=B[j],F[i,j]=max&#123;F[i<span class="number">-1</span>,k]&#125;+<span class="number">1</span>;(<span class="number">0</span>&lt;=k&lt;j)</span><br></pre></td></tr></table></figure><p>未优化前，<br>考虑当<code>a[i]==b[j]</code>时，上一步从b[1]~b[j]中的某一个b[k]转化而来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="type">int</span> maxv=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;j;k++)</span><br><span class="line">                    <span class="keyword">if</span> (a[i]&gt;b[k]) maxv=<span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][k] + <span class="number">1</span>);</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[n][j]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>TLE了，发现可以没必要枚举k，可以用val实时更新前缀的max长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">//a1~ai,b1~bj可以构成的以bj结尾的LCIS的长度</span></span><br><span class="line"><span class="type">int</span> n,a[N],b[N],ans=<span class="number">0</span>,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val=<span class="number">0</span>;<span class="comment">//(i,0)的LCIS长度</span></span><br><span class="line">        <span class="comment">//i固定，b1-&gt;bn时LCIS长度一定是单调递增的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) f[i][j]=val+<span class="number">1</span>;<span class="comment">//遍历到一个ai、bj相同的位置，长度++</span></span><br><span class="line">            <span class="keyword">else</span> f[i][j]=f[i<span class="number">-1</span>][j];<span class="comment">//不相等，直接继承(i-1,j)的长度</span></span><br><span class="line">            <span class="keyword">if</span>(b[j]&lt;a[i]) val=<span class="built_in">max</span>(val,f[i<span class="number">-1</span>][j]);<span class="comment">//更新val:(i,j)前面的LCIS长度</span></span><br><span class="line">            <span class="comment">//另一种情况：(b[j]&gt;a[i])一定不会影响到LCIS的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//找出所有以bj结尾的LCIS中长度最大的</span></span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[n][j]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步发现f的第一维也是可以省略的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//a1~ai,b1~bj可以构成的以bj结尾的LCIS的长度</span></span><br><span class="line"><span class="type">int</span> n,a[N],b[N],ans=<span class="number">0</span>,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val=<span class="number">0</span>;<span class="comment">//(i,0)的LCIS长度</span></span><br><span class="line">        <span class="comment">//i固定，b1-&gt;bn时LCIS长度一定是单调递增的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) f[j]=val+<span class="number">1</span>;<span class="comment">//遍历到一个ai、bj相同的位置，长度++</span></span><br><span class="line">            <span class="keyword">if</span>(b[j]&lt;a[i]) val=<span class="built_in">max</span>(val,f[j]);<span class="comment">//更新val:(i,j)前面的LCIS长度</span></span><br><span class="line">            <span class="comment">//另一种情况：(b[j]&gt;a[i])一定不会影响到LCIS的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//找出所有以bj结尾的LCIS中长度最大的</span></span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[j]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LCIS"><a href="#LCIS" class="headerlink" title="LCIS"></a>LCIS</h1><p><a href="https://www.luogu.com.cn/problem/CF10D">LCIS</a></p><p>加上路径输出，scheme保存前一个位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//a1~ai,b1~bj可以构成的以bj结尾的LCIS的长度</span></span><br><span class="line"><span class="type">int</span> n,a[N],b[N],ans[N],m,scheme[N],p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i固定，b1-&gt;bn时LCIS长度一定是单调递增的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]) f[j]=f[id]+<span class="number">1</span>,scheme[j]=id;</span><br><span class="line"><span class="comment">//遍历到一个ai、bj相同的位置，长度++,记录下j前面一个位置是id </span></span><br><span class="line">            <span class="keyword">if</span>(b[j]&lt;a[i]&amp;&amp;f[id]&lt;f[j]) id=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;f[p]) p=i;<span class="comment">//找出所有以bj结尾的LCIS中长度最大的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[p]);</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f[p]--) </span><br><span class="line">&#123;</span><br><span class="line">        ans[++top]=b[p];</span><br><span class="line">        id=scheme[p];<span class="comment">//从后往前倒出来 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);<span class="comment">//输出方案前需要记录</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="273-分级"><a href="#273-分级" class="headerlink" title="273. 分级"></a>273. 分级</h1><p><a href="https://www.acwing.com/problem/content/description/275/">273. 分级</a></p><p>即将一个序列转化成非严格单调递增（或者递减）序列的最小代价。<br><strong>引理：在满足ans最小的情况下，一定存在一种构造序列b的方法，使得b中的数值都在a中出现过。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态转移：F[i,j]=min&#123;F[i<span class="number">-1</span>,k]&#125;+|A[i]-j|;(<span class="number">0</span>&lt;=k&lt;j)</span><br></pre></td></tr></table></figure><p>像LCIS那题所述，优化枚举k的一维。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2020</span>;</span><br><span class="line">LL a[N],b[N],f[N][N];</span><br><span class="line"><span class="comment">//f[i][j]表示已经考虑前a[i]个且最后一个以b[j]结尾的最优解</span></span><br><span class="line">LL ans=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL temp=<span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=<span class="built_in">min</span>(temp,f[i<span class="number">-1</span>][j]);<span class="comment">//对前缀取最小</span></span><br><span class="line">            f[i][j]=temp+<span class="built_in">abs</span>(a[i]-b[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,f[n][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line">     <span class="comment">//引理：在满足ans最小的情况下，一定存在一种构造序列b的方法，使得b中的数值都在a中出现过</span></span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);<span class="built_in">work</span>();<span class="comment">//b[i]单调递增的情况下取一遍答案</span></span><br><span class="line">    <span class="built_in">reverse</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);<span class="built_in">work</span>();<span class="comment">//b[i]单调递减的情况下取一遍答案</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><h1 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h1><p><a href="https://www.luogu.com.cn/problem/CF13C">Sequence</a></p><p>比起上一题会卡空间，要优化一维。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5050</span>;</span><br><span class="line">LL a[N],b[N],f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line">     <span class="comment">//引理：在满足ans最小的情况下，一定存在一种构造序列b的方法，使得b中的数值都在a中出现过</span></span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]+=<span class="built_in">abs</span>(b[j]-a[i]);</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">1</span>)f[j]=<span class="built_in">min</span>(f[j],f[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P4597-序列-sequence"><a href="#P4597-序列-sequence" class="headerlink" title="P4597 序列 sequence"></a>P4597 序列 sequence</h1><p><a href="https://www.luogu.com.cn/problem/P4597">P4597 序列 sequence</a></p><p>卡$O(N^2)$的时间复杂度啦，要用堆优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL n,ans,x;</span><br><span class="line">priority_queue&lt;LL&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">    q.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">top</span>()&gt;x)</span><br><span class="line">&#123;</span><br><span class="line">            ans+=q.<span class="built_in">top</span>()-x;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>P.S.</p><p>Q：把一个序列变成非严格单调递增的，至少需要修改几个数？</p><p>A：序列A的总长度减去A的最长不下降子序列长度。</p><p>Q：把一个序列A变成严格单调递增的，至少需要修改几个数？ </p><p>A：构造序列$B[i]=A[i]-i$,答案为序列总长度减去B的最长不下降子序列长度。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 线性DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矢量场的散度和旋度</title>
      <link href="/2022/11/04/%E6%95%A3%E5%BA%A6%E5%92%8C%E6%97%8B%E5%BA%A6/"/>
      <url>/2022/11/04/%E6%95%A3%E5%BA%A6%E5%92%8C%E6%97%8B%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="散度"><a href="#散度" class="headerlink" title="散度"></a>散度</h1><p>散度是一个标量，用于体现矢量场各点发散的强弱程度。对于矢量场${ \textbf{F}}$：</p><p>${\color{DarkRed} div \textbf{F}  = \displaystyle \lim<em>{ \Delta V \to 0}\tfrac{\oint</em>{S} \textbf{F}\cdot d\textbf{S}}{\Delta V} = \nabla \, \cdot \, \textbf{F}}$</p><p>${ div \textbf{F}}$描述通量源的密度。</p><p> <strong>散度定理（高斯定理）：</strong></p><p>${\color{Red} \int<em>{V}\nabla\,\cdot \,\textbf{F}dV = \oint</em>{S}\textbf{F}\,\cdot \,d\textbf{S}}$</p><h1 id="旋度"><a href="#旋度" class="headerlink" title="旋度"></a>旋度</h1><p>散度是一个矢量，用于体现矢量场各点附近环流的强弱程度。对于矢量场${ \textbf{F}}$：</p><p>${\color{DarkRed} rot \textbf {F}  = \displaystyle \lim<em>{ \Delta S \to 0}\tfrac{1}{\Delta S}\oint</em>{S} \textbf{F}\cdot d\textbf{l}\mathrel{|_{max}} =  \nabla \, \times \, \textbf{F}}$</p><p>${ rot \textbf{F}}$描述旋涡源的密度。</p><p> <strong>斯托克斯定理：</strong></p><p>${\color{Red}\int<em>{S}\nabla\,\times  \,\textbf{F}d\textbf{S} = \oint</em>{C}\textbf{F}\,\times  \,d\textbf{l}}$</p><h1 id="nabla-Nabla算子"><a href="#nabla-Nabla算子" class="headerlink" title="$\nabla$ Nabla算子"></a>$\nabla$ Nabla算子</h1><p><strong>含义</strong>：三维直角坐标系中，</p><p>$\nabla f=\left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z}\right)=\mathbf{i}\frac{\partial f}{\partial x}+\mathbf j\frac{\partial f}{\partial y}+\mathbf k\frac{\partial f}{\partial z}$</p><p>其中，$\mathbf i， \mathbf j ，\mathbf k$ 依次是 x 、 y 、 z 方向的单位矢量（算子含义与坐标系选取无关，仅列出在三维直角坐标系中的表达式）。</p><p><strong>各种意义：</strong></p><ol><li><p>作用于标量场 $u$ 得到梯度 $\textbf{grad}\, u=\nabla u$;</p></li><li><p>与矢量函数点乘得散度：$div\textbf{F} =  \nabla \, \cdot \, \textbf{F}$;</p></li><li><p>与矢量函数叉乘得旋度：$rot\textbf{F} =  \nabla \, \times \, \textbf{F}$;</p></li></ol><p>感性理解为什么求散度用点乘，求旋度用叉乘（看3b1b的www）：</p><p>点乘可以衡量两个向量的共线程度，此处即是衡量位移向量和场向量的共线程度（如图对于正通量源点蓝绿色是场向量，红色是位移向量）；</p><p><img src="https://img-blog.csdnimg.cn/67b1efb630ab4d5dbab80a5429640f74.jpeg" alt="在这里插入图片描述"></p><p>叉乘可以衡量两个向量的垂直程度，此处即是衡量位移向量和场向量的垂直程度；<br><img src="https://img-blog.csdnimg.cn/3505c01ebc4d4d538f8bf0c3323ebce7.jpeg" alt="在这里插入图片描述"></p><h1 id="重要定理"><a href="#重要定理" class="headerlink" title="重要定理"></a>重要定理</h1><p><strong>格林定理</strong>：描述两个标量场之间满足的关系，如果其中已知其中一个场的分布，可以用格林定理求解另一个场的分布。<br><img src="https://img-blog.csdnimg.cn/ed9e7dc6002d4f8fb10829dde30f2a5c.jpeg" alt="在这里插入图片描述"></p><p><strong>亥姆霍兹定理：</strong><br>在任何有限区域V内，任一矢量场由它的散度、旋度和边界条件惟一地确定。</p>]]></content>
      
      
      <categories>
          
          <category> 电磁场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电磁场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2022/10/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/10/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>线段树是一种基于分治思想的二叉树结构，用于在区间上进行统计。每个节点代表一个区间，对于每个内部节点[l,r]（编号p），左子节点代表区间[l,mid]（编号2p），右子节点代表区间[mid+1,r]（编号2p+1）.可以用结构体数组保存一棵线段树，数组大小开到N*4<br><img src="https://img-blog.csdnimg.cn/c3451ab44ecd41929b95819808f52d22.png" alt="在这里插入图片描述"></p><p><a href="https://www.luogu.com.cn/problem/P2068">P2068 统计和</a></p><p>定义线段树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">&#125;tree[<span class="number">100010</span>*<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>建树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[p].l=l,tree[p].r=r,tree[p].sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;<span class="comment">//到达根节点 </span></span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);<span class="comment">//左子树 </span></span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);<span class="comment">//右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>单点修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p].l==tree[p].r)<span class="comment">//到达对应单点（左右端点值都为x） </span></span><br><span class="line">&#123;</span><br><span class="line">tree[p].sum+=v;<span class="comment">//修改 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(tree[p].l+tree[p].r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,x,v);<span class="comment">//单点在左子树 </span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,x,v);<span class="comment">//单点在右子树 </span></span><br><span class="line">tree[p].sum=(tree[p*<span class="number">2</span>].sum+tree[p*<span class="number">2</span>+<span class="number">1</span>].sum);<span class="comment">//合并 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>区间查询</p><p>假设当前询问的区间为[l,r]<br>递归到一个区间[tl,tr]时,有四种情况：</p><ol><li>$l&lt;=tl&lt;=tr&lt;=r$,该区间被完全覆盖在询问区间内，直接返回[tr,tl]上的和；</li><li>$tl&lt;=l&lt;=tr&lt;=r$,当前区间的右边一部分在询问区间内，判断l与mid=(tr+tl)/2的大小关系，若l&gt;mid，只需递归右子树，否则需要递归左右子树（右子树会在递归后直接返回）</li><li>$l&lt;=tl&lt;=r&lt;=tr$,参考上一条</li><li>$tr&lt;=l&lt;=r&lt;=tr$，递归左右子树<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) </span><br><span class="line"><span class="keyword">return</span> tree[p].sum;<span class="comment">//如果整个区间被覆盖，就返回维护的值</span></span><br><span class="line">    <span class="type">int</span> mid=(tree[p].l+tree[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);<span class="comment">//累加答案，返回左右儿子的和</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">&#125;tree[<span class="number">100010</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[p].l=l,tree[p].r=r,tree[p].sum=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;p:&quot;&lt;&lt;p&lt;&lt;&quot; l:&quot;&lt;&lt;l&lt;&lt;&quot; r:&quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;<span class="comment">//到达根节点 </span></span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);<span class="comment">//左子树 </span></span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);<span class="comment">//右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p].l==tree[p].r)<span class="comment">//到达对应单点（左右端点值都为x） </span></span><br><span class="line">&#123;</span><br><span class="line">tree[p].sum+=v;<span class="comment">//修改 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(tree[p].l+tree[p].r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,x,v);<span class="comment">//单点在左子树 </span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,x,v);<span class="comment">//单点在右子树 </span></span><br><span class="line">tree[p].sum=(tree[p*<span class="number">2</span>].sum+tree[p*<span class="number">2</span>+<span class="number">1</span>].sum);<span class="comment">//合并 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r) </span><br><span class="line"><span class="keyword">return</span> tree[p].sum;<span class="comment">//如果整个区间被覆盖，就返回维护的值</span></span><br><span class="line">    <span class="type">int</span> mid=(tree[p].l+tree[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);<span class="comment">//累加答案，返回左右儿子的和</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c; <span class="type">int</span> x,y;</span><br><span class="line">cin&gt;&gt;c&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span> (c==<span class="string">&#x27;x&#x27;</span>) <span class="built_in">change</span>(<span class="number">1</span>,x,y);<span class="comment">//单点修改 </span></span><br><span class="line"><span class="keyword">if</span> (c==<span class="string">&#x27;y&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,x,y));<span class="comment">//区间查询 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1198">P1198 [JSOI2008] 最大数</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> m,mod,now=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> temp;</span><br><span class="line"><span class="type">int</span> t[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[p]=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=now) <span class="built_in">insert</span>(p*<span class="number">2</span>,l,mid,x);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;now) <span class="built_in">insert</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">t[p]=<span class="built_in">max</span>(t[p*<span class="number">2</span>],t[p*<span class="number">2</span>+<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ll&lt;=l&amp;&amp;rr&gt;=r)</span><br><span class="line"><span class="keyword">return</span> t[p];</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> maxn=<span class="number">-0x3ffffff</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=ll) maxn=<span class="built_in">max</span>(maxn,<span class="built_in">ask</span>(p*<span class="number">2</span>,l,mid,ll,rr));</span><br><span class="line"><span class="keyword">if</span>(mid&lt;rr) maxn=<span class="built_in">max</span>(maxn,<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,ll,rr));</span><br><span class="line"><span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">++now;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="type">int</span> a=(x+temp)%mod;</span><br><span class="line"><span class="built_in">insert</span>(<span class="number">1</span>,<span class="number">1</span>,m,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line"><span class="keyword">if</span>(len==<span class="number">0</span>) temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> temp=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,m,now-len+<span class="number">1</span>,now)%mod;</span><br><span class="line">cout&lt;&lt;temp&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;now:&quot;&lt;&lt;now&lt;&lt;&quot; temp:&quot;&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;t[1].val:&quot;&lt;&lt;t[1]&lt;&lt;&quot;t[2].val:&quot;&lt;&lt;t[2]&lt;&lt;&quot;t[3].val:&quot;&lt;&lt;t[3]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p> <a href="https://www.luogu.com.cn/problem/P1471">P1471 方差</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">double</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">double</span> sum,total,add;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].total+=<span class="number">2</span>*tr[u&lt;&lt;<span class="number">1</span>].sum*tr[u].add+(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].sum+=(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].total+=<span class="number">2</span>*tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum*tr[u].add+(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">tr[u]=&#123;l,r,a[l],a[l]*a[l],<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tr[u].l=l,tr[u].r=r;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; </span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">tr[u].total=tr[u&lt;&lt;<span class="number">1</span>].total+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">double</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">tr[u].total+=<span class="number">2</span>*tr[u].sum*v+(tr[u].r-tr[u].l+<span class="number">1</span>)*v*v;</span><br><span class="line">tr[u].sum+=(tr[u].r-tr[u].l+<span class="number">1</span>)*v;</span><br><span class="line">tr[u].add+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,v); </span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,v);</span><br><span class="line">tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">tr[u].total=tr[u&lt;&lt;<span class="number">1</span>].total+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u];</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">Node res,tmp;</span><br><span class="line">res.sum=<span class="number">0</span>,res.total=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) tmp=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r),res.total+=tmp.total,res.sum+=tmp.sum;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) tmp=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r),res.total+=tmp.total,res.sum+=tmp.sum;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">double</span> v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf&quot;</span>,&amp;l,&amp;r,&amp;v);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,l,r,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">Node t1=<span class="built_in">query</span>(<span class="number">1</span>,l,r);</span><br><span class="line"><span class="type">double</span> ave=t1.sum*<span class="number">1.0</span>/(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> s=t1.total*<span class="number">1.0</span>/(r-l+<span class="number">1</span>)-ave*ave;</span><br><span class="line"><span class="comment">//printf(&quot;t.total:%.ld t.sum:%ld ave:%.4lf s:%.4lf\n&quot;,t2,t1,ave,s);</span></span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,ave);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="延迟操作"><a href="#延迟操作" class="headerlink" title="延迟操作"></a>延迟操作</h1><p><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a><br>延迟标记<br>之前遇到区间修改时可能会遍历区间内的所有数，效率极其低下，有了线段树这种每个结点代表一个区间的数据结构，我们可以在结构体里新增一个变量add，用于储存对区间的增值操作，在未访问到这个区间时，我们可以不用管（这样就省掉了很多无用功233），如果访问到这个区间，就把这个区间对应的sum值加上（add*区间内点数），将add下放到左右两个子树，再将当前节点的add归零。<br>延迟标记的含义为“该节点曾经被修改，但其子节点尚未被更新”，其本身信息已被修改完毕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p].add!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tree[p*<span class="number">2</span>].sum+=(tree[p*<span class="number">2</span>].r-tree[p*<span class="number">2</span>].l+<span class="number">1</span>)*tree[p].add;=</span><br><span class="line">tree[p*<span class="number">2</span>+<span class="number">1</span>].sum+=(tree[p*<span class="number">2</span>+<span class="number">1</span>].r-tree[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)*tree[p].add;=</span><br><span class="line">tree[p*<span class="number">2</span>].add+=tree[p].add;</span><br><span class="line">tree[p*<span class="number">2</span>+<span class="number">1</span>].add+=tree[p].add;</span><br><span class="line">tree[p].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum,add;</span><br><span class="line">&#125;tree[<span class="number">100010</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[p].l=l,tree[p].r=r;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">tree[p].sum=a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">tree[p].sum=tree[p*<span class="number">2</span>].sum+tree[p*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p].add!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tree[p*<span class="number">2</span>].sum+=(tree[p*<span class="number">2</span>].r-tree[p*<span class="number">2</span>].l+<span class="number">1</span>)*tree[p].add;=</span><br><span class="line">tree[p*<span class="number">2</span>+<span class="number">1</span>].sum+=(tree[p*<span class="number">2</span>+<span class="number">1</span>].r-tree[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)*tree[p].add;=</span><br><span class="line">tree[p*<span class="number">2</span>].add+=tree[p].add;</span><br><span class="line">tree[p*<span class="number">2</span>+<span class="number">1</span>].add+=tree[p].add;</span><br><span class="line">tree[p].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)</span><br><span class="line">&#123;</span><br><span class="line">tree[p].sum+=(<span class="type">long</span> <span class="type">long</span>)x*(tree[p].r-tree[p].l+<span class="number">1</span>);</span><br><span class="line">tree[p].add+=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spread</span>(p);<span class="comment">//延迟标记</span></span><br><span class="line"><span class="type">int</span> mid=(tree[p].l+tree[p].r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,l,r,x);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">tree[p].sum=tree[p*<span class="number">2</span>].sum+tree[p*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l &amp;&amp; r&gt;=tree[p].r) </span><br><span class="line"><span class="keyword">return</span> tree[p].sum;<span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line">    <span class="built_in">spread</span>(p);<span class="comment">//下传延迟标记，并查询左右儿子</span></span><br><span class="line">    <span class="type">int</span> mid=(tree[p].l+tree[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);<span class="comment">//累加答案，返回左右儿子的和</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P2574">P2574 XOR的艺术</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200020</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r,num,mark;</span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p].l=l,t[p].r=r;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].num=a[l];</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;p:&quot;&lt;&lt;p&lt;&lt;&#x27; &#x27;&lt;&lt;a[l]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[p].num=t[p*<span class="number">2</span>].num+t[p*<span class="number">2</span>+<span class="number">1</span>].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].mark)</span><br><span class="line">&#123;</span><br><span class="line">t[p*<span class="number">2</span>].num=(t[p*<span class="number">2</span>].r-t[p*<span class="number">2</span>].l+<span class="number">1</span>)-t[p*<span class="number">2</span>].num;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].num=(t[p*<span class="number">2</span>+<span class="number">1</span>].r-t[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)-t[p*<span class="number">2</span>+<span class="number">1</span>].num;</span><br><span class="line">t[p*<span class="number">2</span>].mark^=<span class="number">1</span>;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].mark^=<span class="number">1</span>;</span><br><span class="line">t[p].mark=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].num=(t[p].r-t[p].l+<span class="number">1</span>)-t[p].num;</span><br><span class="line">t[p].mark^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">t[p].num=t[p*<span class="number">2</span>].num+t[p*<span class="number">2</span>+<span class="number">1</span>].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].l&gt;=l&amp;&amp;t[p].r&lt;=r) </span><br><span class="line"><span class="keyword">return</span> t[p].num;<span class="comment">//如果完全包含，返回区间</span></span><br><span class="line"><span class="type">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">spread</span>(p);<span class="comment">//下传标记</span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);<span class="comment">//继续向下</span></span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>) cout&lt;&lt;<span class="built_in">ask</span>(<span class="number">1</span>,l,r)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">0</span>) <span class="built_in">change</span>(<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1438">P1438 无聊的数列</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">LL sum,add;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].sum+=(tr[u&lt;&lt;<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum+=(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r-tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l+<span class="number">1</span>)*tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add+=tr[u].add;</span><br><span class="line">tr[u].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">tr[u].sum+=(tr[u].r-tr[u].l+<span class="number">1</span>)*v;</span><br><span class="line">        tr[u].add+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,v);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,v);</span><br><span class="line">tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">LL sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r,k,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k,&amp;d);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,l,l,k);</span><br><span class="line"><span class="keyword">if</span>(l&lt;r) <span class="built_in">modify</span>(<span class="number">1</span>,l+<span class="number">1</span>,r,d);</span><br><span class="line"><span class="keyword">if</span>(r&lt;n) <span class="built_in">modify</span>(<span class="number">1</span>,r+<span class="number">1</span>,r+<span class="number">1</span>,-k-d*(r-l));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[x]+<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的容易在各种奇奇怪怪的地方打错啊，(✖人✖)。<br>如果有更多种操作（乘上一个值等）可以在结构体再开别的变量，保存标记信息，但需要各个标记下放的顺序。这模板2要了我老命，爬</p><p><a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2</a></p><p>区间乘法：将整个区间上的数乘上一个数时同时要把它储存的add和mu都乘上该数。每次延迟标记下放遵循“先乘后加”：先把区间上的数乘上储存的mu再作区间加法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">1000005</span>],mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line">ll sum,l,r,mu,add;</span><br><span class="line">&#125;t[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p].l=l,t[p].r=r,t[p].mu=<span class="number">1</span>;<span class="comment">//乘法运算的幺元是1 </span></span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].sum=a[l]%mod;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[p].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(ll p)</span><span class="comment">//重点关注 ！！！ </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">t[p*<span class="number">2</span>].sum=(t[p*<span class="number">2</span>].sum*t[p].mu+(t[p*<span class="number">2</span>].r-t[p*<span class="number">2</span>].l+<span class="number">1</span>)*t[p].add%mod)%mod;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].sum=(t[p*<span class="number">2</span>+<span class="number">1</span>].sum*t[p].mu+(t[p*<span class="number">2</span>+<span class="number">1</span>].r-t[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)*t[p].add%mod)%mod;</span><br><span class="line">t[p*<span class="number">2</span>].mu=(t[p*<span class="number">2</span>].mu*t[p].mu)%mod;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].mu=(t[p*<span class="number">2</span>+<span class="number">1</span>].mu*t[p].mu)%mod;</span><br><span class="line">t[p*<span class="number">2</span>].add=(t[p*<span class="number">2</span>].add*t[p].mu+t[p].add)%mod;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].add=(t[p*<span class="number">2</span>+<span class="number">1</span>].add*t[p].mu+t[p].add)%mod;</span><br><span class="line">t[p].add=<span class="number">0</span>;</span><br><span class="line">t[p].mu=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pluss</span><span class="params">(ll p,ll l,ll r,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].sum=(t[p].sum+(t[p].r-t[p].l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">t[p].add+=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line">ll mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">pluss</span>(p*<span class="number">2</span>,l,r,x);<span class="comment">//一直都是（l,r)，算出mid仅用于比较 </span></span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) <span class="built_in">pluss</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">t[p].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mu</span><span class="params">(ll p,ll l,ll r,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].add=(t[p].add*x)%mod;</span><br><span class="line">t[p].mu=(t[p].mu*x)%mod;</span><br><span class="line">t[p].sum=(t[p].sum*x)%mod;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line">ll mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">mu</span>(p*<span class="number">2</span>,l,r,x);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) <span class="built_in">mu</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">t[p].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)</span><br><span class="line"><span class="keyword">return</span> t[p].sum;</span><br><span class="line"><span class="built_in">spread</span>(p);<span class="comment">//每次询问到这里也要下放标记 </span></span><br><span class="line">ll mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll val=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) val=(val+<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r))%mod;</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r )val=(val+<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r))%mod;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll cn=<span class="built_in">read</span>(),cm=<span class="built_in">read</span>(),cw=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">mu</span>(<span class="number">1</span>,cn,cm,cw);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll cn=<span class="built_in">read</span>(),cm=<span class="built_in">read</span>(),cw=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">pluss</span>(<span class="number">1</span>,cn,cm,cw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">ll cn=<span class="built_in">read</span>(),cm=<span class="built_in">read</span>();</span><br><span class="line">cout&lt;&lt;<span class="built_in">ask</span>(<span class="number">1</span>,cn,cm)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><p><a href="https://www.acwing.com/problem/content/249/">247. 亚特兰蒂斯</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> x,y1,y2;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> segment &amp;t)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;seg[N*<span class="number">2</span>];<span class="comment">//储存竖线 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">double</span> len;</span><br><span class="line">&#125;tr[N*<span class="number">8</span>];<span class="comment">//在纵坐标上建线段树 </span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt;line;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">lower_bound</span>(line.<span class="built_in">begin</span>(),line.<span class="built_in">end</span>(),x)-line.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[u].cnt) tr[u].len=line[tr[u].r+<span class="number">1</span>]-line[tr[u].l];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l!=tr[u].r)</span><br><span class="line">tr[u].len=tr[u&lt;&lt;<span class="number">1</span>].len+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line"><span class="keyword">else</span> tr[u].len=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(l!=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)</span><br><span class="line">tr[u].cnt+=k;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=(tr[u].l+tr[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n)</span><br><span class="line">&#123;</span><br><span class="line">line.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> x1,x2,y1,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">seg[cnt++]=&#123;x1,y1,y2,<span class="number">1</span>&#125;;<span class="comment">//k==1表示矩形左边 </span></span><br><span class="line">seg[cnt++]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;<span class="comment">//k==2表示矩形右边 </span></span><br><span class="line">line.<span class="built_in">push_back</span>(y1);</span><br><span class="line">line.<span class="built_in">push_back</span>(y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(line.<span class="built_in">begin</span>(),line.<span class="built_in">end</span>());</span><br><span class="line">        line.<span class="built_in">erase</span>(<span class="built_in">unique</span>(line.<span class="built_in">begin</span>(),line.<span class="built_in">end</span>()),line.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,line.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">sort</span>(seg,seg+<span class="number">2</span>*n);</span><br><span class="line"><span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>) ans+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].y1),<span class="built_in">find</span>(seg[i].y2)<span class="number">-1</span>,seg[i].k); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>,T++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h1><p><a href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 2</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n,m,tot,total,root[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>+N*<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[p].l=<span class="built_in">build</span>(l,mid),tr[p].r=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q=++tot;<span class="comment">//点分裂</span></span><br><span class="line">    tr[q]=tr[p];</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[q].cnt++;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) tr[q].l=<span class="built_in">insert</span>(tr[p].l,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> tr[q].r=<span class="built_in">insert</span>(tr[p].r,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    tr[q].cnt=tr[tr[q].l].cnt+tr[tr[q].r].cnt;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> dif=tr[tr[q].l].cnt-tr[tr[p].l].cnt;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=dif) <span class="keyword">return</span> <span class="built_in">query</span>(tr[p].l,tr[q].l,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tr[p].r,tr[q].r,mid+<span class="number">1</span>,r,k-dif);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),b[i]=a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    total=<span class="built_in">unique</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>)-a<span class="number">-1</span>;</span><br><span class="line">    root[<span class="number">0</span>]=<span class="built_in">build</span>(<span class="number">1</span>,total);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        b[i]=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+total+<span class="number">1</span>,b[i])-a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        root[i]=<span class="built_in">insert</span>(root[i<span class="number">-1</span>],<span class="number">1</span>,total,b[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[<span class="built_in">query</span>(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,total,k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.luogu.com.cn/problem/P1972">P1972 [SDOI2009] HH的项链</a><br>每次都是先把$last[a[i]]$的位置先改了（之前没有的话就直接继承上一个节点的了），形成树t，再在t的基础上继续修改。查询的时候我们用右端点控制树的版本，而用左端点控制范围。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],root[N],last[N],ans[N],tot,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N*<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=++tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tr[p].l=<span class="built_in">build</span>(l,mid),tr[p].r=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> idx,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q=++tot;<span class="comment">//点分裂</span></span><br><span class="line">    tr[q]=tr[p],tr[q].cnt+=x;</span><br><span class="line"><span class="keyword">if</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(idx&lt;=mid) tr[q].l=<span class="built_in">insert</span>(tr[p].l,idx,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> tr[q].r=<span class="built_in">insert</span>(tr[p].r,idx,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> idx,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[q].cnt;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(idx&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(idx,tr[q].l,l,mid)+tr[tr[q].r].cnt;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(idx,tr[q].r,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">root[<span class="number">0</span>]=<span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(!last[a[i]])<span class="comment">//该数据第一次出现 </span></span><br><span class="line">root[i]=<span class="built_in">insert</span>(root[i<span class="number">-1</span>],i,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="built_in">insert</span>(root[i<span class="number">-1</span>],last[a[i]],<span class="number">1</span>,n,<span class="number">-1</span>);</span><br><span class="line">root[i]=<span class="built_in">insert</span>(t,i,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">last[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(l,root[r],<span class="number">1</span>,n));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDQ分治</title>
      <link href="/2022/10/10/CDQ%E5%88%86%E6%B2%BB/"/>
      <url>/2022/10/10/CDQ%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_44538273/article/details/88611788">CDQ</a></p><blockquote><p><strong>使用cdq分治的条件</strong>：</p><p> 修改操作对询问的贡献独立，修改操作相互不影响 题目可以使用离线算法，不必强制在线（询问次数可以保存在数组）</p><p><strong>cdq分治的性质：</strong> </p><p>cdq分治通过对时间复杂度增加一个log来降维 cdq可以用来代替复杂的数据结构 在cdq分治中，对于划分出来的两个区间，前一个子问题需要用来解决后一个子问题。</p><p><strong>cdq使用步骤：</strong> </p><p>将整个操作序列分为两个长度相等的部分。 递归处理前一部分的子问题（治1） 计算前一部分子问题的修改操作对后一部分子问题的影响（治2） 递归处理后一部分的子问题（治3）</p></blockquote><p>离线，处理点对关系，常用于降维度，<br>归并排序（合并左右区间，逐级向上）：</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> temp[<span class="number">500005</span>],a[<span class="number">500005</span>],n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">merge</span>(l,mid);</span><br><span class="line"><span class="built_in">merge</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="type">int</span> i=l,j=mid+<span class="number">1</span>,p=l;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">temp[p++]=a[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans+=(mid-i+<span class="number">1</span>),<span class="comment">//计算逆序数 </span></span><br><span class="line">temp[p++]=a[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">temp[p++]=a[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">temp[p++]=a[j++];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)</span><br><span class="line">a[k]=temp[k];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">merge</span>(<span class="number">1</span>,n);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="二维偏序"><a href="#二维偏序" class="headerlink" title="二维偏序"></a>二维偏序</h1><p><a href="https://www.luogu.com.cn/problem/P2717">P2717 寒假作业</a><br><img src="https://img-blog.csdnimg.cn/9c129308fdc84b7abf21b9872207df17.png" alt="在这里插入图片描述"></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],s[N],n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> a[l]&gt;=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">res+=<span class="built_in">cdq</span>(l,mid);</span><br><span class="line">res+=<span class="built_in">cdq</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">s[mid]=a[mid],s[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=mid<span class="number">-1</span>;i&gt;=l;i--) s[i]=s[i+<span class="number">1</span>]+a[i];<span class="comment">//左半部分求后缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">2</span>;i&lt;=r;i++) s[i]=s[i<span class="number">-1</span>]+a[i];<span class="comment">//右半部分求前缀和</span></span><br><span class="line"><span class="built_in">sort</span>(s+l,s+mid+<span class="number">1</span>),<span class="built_in">sort</span>(s+mid+<span class="number">1</span>,s+r+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> p=l,q=r;</span><br><span class="line"><span class="keyword">while</span>(p&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(q&gt;=mid+<span class="number">1</span>&amp;&amp;s[p]+s[q]&gt;=<span class="number">0</span>) q--;</span><br><span class="line">res+=r-q;<span class="comment">//左端点固定，符合条件的右端点数</span></span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">a[i]-=k;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">cdq</span>(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></h2><p><a href="https://www.luogu.com.cn/problem/P5459">P5459 [BJOI2016]回转寿司</a></p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line"><span class="type">int</span> n,L,R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> a[l]&gt;=L&amp;&amp;a[l]&lt;=R;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">res+=<span class="built_in">cdq</span>(l,mid);</span><br><span class="line">res+=<span class="built_in">cdq</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="type">int</span> head=l,tail=l<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(tail+<span class="number">1</span>&lt;=mid&amp;&amp;a[i]-a[tail+<span class="number">1</span>]&gt;=L) tail++;<span class="comment">//最终a[i]-a[tail]&gt;=L</span></span><br><span class="line"><span class="keyword">while</span>(head&lt;=mid&amp;&amp;a[i]-a[head]&gt;R) head++;<span class="comment">//最终a[i]-a[head]&lt;=R</span></span><br><span class="line">res+=tail-head+<span class="number">1</span>;<span class="comment">//对于每个区间右端点，可行的左端点个数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+l,a+r+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;L&gt;&gt;R;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];<span class="comment">//前缀和数组</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">cdq</span>(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></h2><h1 id="三维偏序"><a href="#三维偏序" class="headerlink" title="三维偏序"></a>三维偏序</h1><p><a href="https://www.luogu.com.cn/problem/P3810">P3810 【模板】三维偏序（陌上花开）</a></p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c,cnt,ans;</span><br><span class="line">&#125;s1[maxn],s2[maxn];</span><br><span class="line"><span class="type">int</span> n,m,k,mx,top,su[maxn];</span><br><span class="line"><span class="type">int</span> c[maxn];<span class="comment">//树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.a==y.a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x.b==y.b)<span class="keyword">return</span> x.c&lt;y.c;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.a&lt;y.a;</span><br><span class="line">&#125;<span class="comment">//第一维排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.b==y.b)</span><br><span class="line"><span class="keyword">return</span> x.c&lt;y.c;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">&#125;<span class="comment">//第二维排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=mx;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]+=val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">tot+=c[i];</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cdq</span>(l,mid);</span><br><span class="line"><span class="built_in">cdq</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">sort</span>(s2+l,s2+mid+<span class="number">1</span>,cmp2);</span><br><span class="line"><span class="built_in">sort</span>(s2+mid+<span class="number">1</span>,s2+r+<span class="number">1</span>,cmp2);</span><br><span class="line"><span class="type">int</span> i=l,j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=mid+<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(s2[j].b&gt;=s2[i].b&amp;&amp;i&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">add</span>(s2[i].c,s2[i].cnt);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">s2[j].ans+=<span class="built_in">query</span>(s2[j].c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=l;p&lt;i;p++)</span><br><span class="line"><span class="built_in">add</span>(s2[p].c,-s2[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">mx=k;<span class="comment">//树状数组的区间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s1[i].a,&amp;s1[i].b,&amp;s1[i].c);</span><br><span class="line"><span class="built_in">sort</span>(s1+<span class="number">1</span>,s1+<span class="number">1</span>+n,cmp1);<span class="comment">//第一维为关键字排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span>(s1[i].a!=s1[i+<span class="number">1</span>].a||s1[i].b!=s1[i+<span class="number">1</span>].b||s1[i].c!=s1[i+<span class="number">1</span>].c)</span><br><span class="line">&#123;</span><br><span class="line">s2[++m]=s1[i];</span><br><span class="line">s2[m].cnt=top;</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//第一维已有序,合并相同节点</span></span><br><span class="line"><span class="built_in">cdq</span>(<span class="number">1</span>,m);<span class="comment">//cdq分治</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">su[s2[i].ans+s2[i].cnt<span class="number">-1</span>]+=s2[i].cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,su[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p><a href="https://www.luogu.com.cn/problem/P3157">P3157 [CQOI2011]动态逆序对</a></p><p>对答案有贡献的点$（i,j）$对满足的条件：<br>$val_i<val_j, pos_i>pos_j, time_i&lt;=time_j$<br>那么这个问题就变成了经典的三维偏序问题，可以通过cdq分治来解决。<br>先对time维排序（不需要额外的处理），在time有序的情况下使得归并区间内的pos有序，将val加到树状数组中。</p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val,pos,time,cnt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Node x,Node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.pos&lt;y.pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pos[N],n,m,tot,c[N];</span><br><span class="line"><span class="comment">//树状数组在val维上建 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch==<span class="string">&#x27;-&#x27;</span>&amp;&amp;(f=<span class="number">-1</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">res+=c[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cdq</span>(l,mid);</span><br><span class="line"><span class="built_in">cdq</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">sort</span>(e+l,e+mid+<span class="number">1</span>,cmp1);</span><br><span class="line"><span class="built_in">sort</span>(e+mid+<span class="number">1</span>,e+r+<span class="number">1</span>,cmp1);<span class="comment">//按照pos排序</span></span><br><span class="line"><span class="type">int</span> i=l,j;<span class="comment">//i为左部分指针，j为右部分指针 </span></span><br><span class="line"><span class="keyword">for</span>(j=mid+<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;e[i].pos&lt;=e[j].pos)<span class="comment">//time_i&lt;=time_j&amp;&amp;pos_i&lt;=pos_j</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">add</span>(e[i].val,e[i].cnt);</span><br><span class="line">i++;</span><br><span class="line">&#125; </span><br><span class="line">ans[e[j].time]+=<span class="number">1ll</span>*e[j].cnt*(<span class="built_in">query</span>(n)-<span class="built_in">query</span>(e[j].val));</span><br><span class="line"><span class="comment">//(query(n)-query(e[j].val)):pos_i&lt;=pos_j&amp;&amp;val_i&gt;val_j形成的逆序对 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=l;p&lt;i;p++)</span><br><span class="line"><span class="built_in">add</span>(e[p].val,-e[p].cnt);<span class="comment">//还原 </span></span><br><span class="line">i=mid;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=r;j&gt;mid;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i&gt;=l&amp;&amp;e[i].pos&gt;=e[j].pos)<span class="comment">//time_i&lt;=time_j&amp;&amp;pos_i&gt;=pos_j</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">add</span>(e[i].val,e[i].cnt);</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">ans[e[j].time]+=<span class="number">1ll</span>*e[j].cnt*<span class="built_in">query</span>(e[j].val<span class="number">-1</span>); </span><br><span class="line"><span class="comment">// query(e[j].val-1):pos_i&gt;=pos_j&amp;&amp;val_i&lt;val_j形成的逆序对 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=mid;p&gt;i;p--)</span><br><span class="line"><span class="built_in">add</span>(e[p].val,-e[p].cnt);<span class="comment">//还原 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">pos[x]=i;</span><br><span class="line">e[++tot]=&#123;x,i,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">e[++tot]=&#123;x,pos[x],i,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时 time维 有序 </span></span><br><span class="line"><span class="built_in">cdq</span>(<span class="number">1</span>,tot);</span><br><span class="line"><span class="comment">//此时ans[0]是原始数列逆序对数，之后的 ans[1]~ans[m]都&lt;=0 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans[i]+=ans[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p><a href="https://www.luogu.com.cn/problem/P4169">P4169 [Violet]天使玩偶/SJY摆棋子</a></p><p>只考虑左下角的所有点，对答案有贡献的点$（i,j）$对满足的条件：<br>$x_i&lt;x_j, y_i&lt;y_j, t_i&lt;t_j$<br>那么这个问题就变成了经典的三维偏序问题，可以通过cdq分治来解决。<br>先对time维排序（不需要额外的处理），在time有序的情况下使得归并区间内的x有序，将(x+y)加到y轴的树状数组中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,tot,num;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y,t,type;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[MAX],maxn;</span><br><span class="line"><span class="type">int</span> ques[N],ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch==<span class="string">&#x27;-&#x27;</span>&amp;&amp;(f=<span class="number">-1</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=maxn;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]=<span class="built_in">max</span>(c[i],val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cls</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=maxn;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">res=<span class="built_in">max</span>(c[i],res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cdq</span>(l,mid);</span><br><span class="line"><span class="built_in">cdq</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">sort</span>(e+l,e+mid+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="built_in">sort</span>(e+mid+<span class="number">1</span>,e+r+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="type">int</span> i=l,j;</span><br><span class="line"><span class="keyword">for</span>(j=mid+<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;e[i].x&lt;=e[j].x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i].type==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;i:&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;e[i].x&lt;&lt;&#x27; &#x27;&lt;&lt;e[i].x+e[i].y&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">add</span>(e[i].y,e[i].x+e[i].y);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(e[j].type==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=maxn;k++)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; c[&quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot;]:&quot;</span>&lt;&lt;c[k];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="type">int</span> temp=<span class="built_in">query</span>(e[j].y);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;query(&quot;</span>&lt;&lt;e[j].y&lt;&lt;<span class="string">&quot;):&quot;</span>&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">ans[e[j].t]=<span class="built_in">min</span>(e[j].x+e[j].y-temp,ans[e[j].t]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=l;p&lt;i;p++)</span><br><span class="line"><span class="built_in">cls</span>(e[p].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">read</span>()+<span class="number">1</span>,y=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">e[++tot]=&#123;x,y,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,x+y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op=<span class="built_in">read</span>(),x=<span class="built_in">read</span>()+<span class="number">1</span>,y=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">e[++tot]=&#123;x,y,i,op&#125;;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">2</span>) ques[++num]=i;</span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,x+y);</span><br><span class="line">&#125;</span><br><span class="line">maxn++;</span><br><span class="line"><span class="built_in">cdq</span>(<span class="number">1</span>,tot);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[ques[i]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将点坐标对称，每次更新答案，可以求出最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,tot,num,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y,t,type;</span><br><span class="line">&#125;e[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[MAX],maxn=<span class="number">-1e9</span>;</span><br><span class="line"><span class="comment">//在y维上建树状数组 </span></span><br><span class="line"><span class="type">int</span> ques[N],ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch==<span class="string">&#x27;-&#x27;</span>&amp;&amp;(f=<span class="number">-1</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mxx=<span class="number">0</span>,myy=<span class="number">0</span>;cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">1</span>) a[i].x=maxn-a[i].x;<span class="comment">//横坐标全部对称过去 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d==<span class="number">2</span>) a[i].y=maxn-a[i].y;<span class="comment">//纵坐标全部对称过去 </span></span><br><span class="line">        <span class="keyword">if</span>(a[i].type==<span class="number">2</span>) mxx=<span class="built_in">max</span>(mxx,a[i].x),myy=<span class="built_in">max</span>(myy,a[i].y);<span class="comment">//更新边界 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+m;++i)</span><br><span class="line">    <span class="keyword">if</span>(a[i].x&lt;=mxx&amp;&amp;a[i].y&lt;=myy)<span class="comment">//可以被询问到的点 </span></span><br><span class="line">    e[++cnt]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=maxn;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]=<span class="built_in">max</span>(c[i],val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cls</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=maxn;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">res=<span class="built_in">max</span>(c[i],res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cdq</span>(l,mid);</span><br><span class="line"><span class="built_in">cdq</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">sort</span>(e+l,e+mid+<span class="number">1</span>,cmp);<span class="comment">//左半部分按x排序 </span></span><br><span class="line"><span class="built_in">sort</span>(e+mid+<span class="number">1</span>,e+r+<span class="number">1</span>,cmp);<span class="comment">//右半部分按x排序 </span></span><br><span class="line"><span class="type">int</span> i=l,j;</span><br><span class="line"><span class="keyword">for</span>(j=mid+<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;e[i].x&lt;=e[j].x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i].type==<span class="number">1</span>)</span><br><span class="line"><span class="built_in">add</span>(e[i].y,e[i].x+e[i].y);<span class="comment">//更新区域最大值 </span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(e[j].type==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//for(int k=1;k&lt;=maxn;k++)</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot; c[&quot;&lt;&lt;k&lt;&lt;&quot;]:&quot;&lt;&lt;c[k];</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line"><span class="type">int</span> temp=<span class="built_in">query</span>(e[j].y);<span class="comment">//查询0~y之间的区域最大值 </span></span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;query(&quot;&lt;&lt;e[j].y&lt;&lt;&quot;):&quot;&lt;&lt;temp&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(temp) ans[e[j].t]=<span class="built_in">min</span>(e[j].x+e[j].y-temp,ans[e[j].t]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=l;p&lt;i;p++)</span><br><span class="line"><span class="keyword">if</span>(e[p].type==<span class="number">1</span>) <span class="built_in">cls</span>(e[p].y);<span class="comment">//还原，清零 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">read</span>()+<span class="number">1</span>,y=<span class="built_in">read</span>()+<span class="number">1</span>;<span class="comment">//题给数据有0 </span></span><br><span class="line">a[++tot]=&#123;x,y,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//初始t==0 </span></span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,x);</span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op=<span class="built_in">read</span>(),x=<span class="built_in">read</span>()+<span class="number">1</span>,y=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">a[++tot]=&#123;x,y,i,op&#125;;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">2</span>) ques[++num]=i,ans[i]=<span class="number">1e9</span>;<span class="comment">//储存下询问 </span></span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,x);</span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,y);</span><br><span class="line">&#125;</span><br><span class="line">maxn++;</span><br><span class="line"><span class="comment">//此时t维已经有序 </span></span><br><span class="line"><span class="built_in">init</span>(<span class="number">0</span>); <span class="built_in">cdq</span>(<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1</span>); <span class="built_in">cdq</span>(<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2</span>); <span class="built_in">cdq</span>(<span class="number">1</span>,cnt);</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">1</span>); <span class="built_in">cdq</span>(<span class="number">1</span>,cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[ques[i]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> CDQ分治 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构2-2】线段树与树状数组 题解</title>
      <link href="/2022/09/20/%E6%B4%9B%E8%B0%B7%E9%A2%98%E5%8D%95%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/09/20/%E6%B4%9B%E8%B0%B7%E9%A2%98%E5%8D%95%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>头一次老老实实写完一个<a href="https://www.luogu.com.cn/training/206#information">官方题单</a>，发篇题解纪念一下。</p><p><img src="https://img-blog.csdnimg.cn/76d0881d7c374f92ac21fa43fe51528e.png" alt="在这里插入图片描述"><br>@[TOC]</p><h1 id="P3372-【模板】线段树-1"><a href="#P3372-【模板】线段树-1" class="headerlink" title="P3372 【模板】线段树 1"></a>P3372 【模板】线段树 1</h1><p>令人惆怅，第一个模板题就有延迟标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum,add;</span><br><span class="line">&#125;tree[<span class="number">100010</span>*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[p].l=l,tree[p].r=r;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;p:&quot;&lt;&lt;p&lt;&lt;&quot; l:&quot;&lt;&lt;l&lt;&lt;&quot; r:&quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">tree[p].sum=a[l];</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;pos:&quot;&lt;&lt;p&lt;&lt;&quot; val:&quot;&lt;&lt;a[l]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">tree[p].sum=tree[p*<span class="number">2</span>].sum+tree[p*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p].add!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tree[p*<span class="number">2</span>].sum+=(tree[p*<span class="number">2</span>].r-tree[p*<span class="number">2</span>].l+<span class="number">1</span>)*tree[p].add;</span><br><span class="line">tree[p*<span class="number">2</span>+<span class="number">1</span>].sum+=(tree[p*<span class="number">2</span>+<span class="number">1</span>].r-tree[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)*tree[p].add;</span><br><span class="line">tree[p*<span class="number">2</span>].add+=tree[p].add;</span><br><span class="line">tree[p*<span class="number">2</span>+<span class="number">1</span>].add+=tree[p].add;</span><br><span class="line">tree[p].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tree[p].l&amp;&amp;r&gt;=tree[p].r)</span><br><span class="line">&#123;</span><br><span class="line">tree[p].sum+=(<span class="type">long</span> <span class="type">long</span>)x*(tree[p].r-tree[p].l+<span class="number">1</span>);</span><br><span class="line">tree[p].add+=x;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;l:&quot;&lt;&lt;tree[p].l&lt;&lt;&quot; r:&quot;&lt;&lt;tree[p].r&lt;&lt;&quot; x:&quot;&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line"><span class="type">int</span> mid=(tree[p].l+tree[p].r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,l,r,x);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">tree[p].sum=tree[p*<span class="number">2</span>].sum+tree[p*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[p].l &amp;&amp; r&gt;=tree[p].r) </span><br><span class="line"><span class="keyword">return</span> tree[p].sum;<span class="comment">//如果被覆盖，就返回维护的值</span></span><br><span class="line">    <span class="built_in">spread</span>(p);<span class="comment">//下传懒标记，并查询左右儿子</span></span><br><span class="line">    <span class="type">int</span> mid=(tree[p].l+tree[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);<span class="comment">//累加答案，返回左右儿子的和</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="P3373-【模板】线段树-2"><a href="#P3373-【模板】线段树-2" class="headerlink" title="P3373 【模板】线段树 2"></a>P3373 【模板】线段树 2</h1><p>令人叹惋，第二个模板题就这么难调。</p><p>区间乘法：将整个区间上的数乘上一个数时同时要把它储存的add和mud都乘上该数。每次延迟标记下放遵循“先乘后加”：先把区间上的数乘上储存的mu再作区间加法。</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">1000005</span>],mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line">ll sum,l,r,mu,add;</span><br><span class="line">&#125;t[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p].l=l,t[p].r=r,t[p].mu=<span class="number">1</span>;<span class="comment">//乘法运算的幺元是1 </span></span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].sum=a[l]%mod;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[p].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(ll p)</span><span class="comment">//重点关注 ！！！ </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">t[p*<span class="number">2</span>].sum=(t[p*<span class="number">2</span>].sum*t[p].mu+(t[p*<span class="number">2</span>].r-t[p*<span class="number">2</span>].l+<span class="number">1</span>)*t[p].add%mod)%mod;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].sum=(t[p*<span class="number">2</span>+<span class="number">1</span>].sum*t[p].mu+(t[p*<span class="number">2</span>+<span class="number">1</span>].r-t[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)*t[p].add%mod)%mod;</span><br><span class="line">t[p*<span class="number">2</span>].mu=(t[p*<span class="number">2</span>].mu*t[p].mu)%mod;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].mu=(t[p*<span class="number">2</span>+<span class="number">1</span>].mu*t[p].mu)%mod;</span><br><span class="line">t[p*<span class="number">2</span>].add=(t[p*<span class="number">2</span>].add*t[p].mu+t[p].add)%mod;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].add=(t[p*<span class="number">2</span>+<span class="number">1</span>].add*t[p].mu+t[p].add)%mod;</span><br><span class="line">t[p].add=<span class="number">0</span>;</span><br><span class="line">t[p].mu=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pluss</span><span class="params">(ll p,ll l,ll r,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].sum=(t[p].sum+(t[p].r-t[p].l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">t[p].add+=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line">ll mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">pluss</span>(p*<span class="number">2</span>,l,r,x);<span class="comment">//一直都是（l,r)，算出mid仅用于比较 </span></span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) <span class="built_in">pluss</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">t[p].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mu</span><span class="params">(ll p,ll l,ll r,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].add=(t[p].add*x)%mod;</span><br><span class="line">t[p].mu=(t[p].mu*x)%mod;</span><br><span class="line">t[p].sum=(t[p].sum*x)%mod;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line">ll mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">mu</span>(p*<span class="number">2</span>,l,r,x);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) <span class="built_in">mu</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">t[p].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)</span><br><span class="line"><span class="keyword">return</span> t[p].sum;</span><br><span class="line"><span class="built_in">spread</span>(p);<span class="comment">//每次询问到这里也要下放标记 </span></span><br><span class="line">ll mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll val=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) val=(val+<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r))%mod;</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r )val=(val+<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r))%mod;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll cn=<span class="built_in">read</span>(),cm=<span class="built_in">read</span>(),cw=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">mu</span>(<span class="number">1</span>,cn,cm,cw);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll cn=<span class="built_in">read</span>(),cm=<span class="built_in">read</span>(),cw=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">pluss</span>(<span class="number">1</span>,cn,cm,cw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">ll cn=<span class="built_in">read</span>(),cm=<span class="built_in">read</span>();</span><br><span class="line">cout&lt;&lt;<span class="built_in">ask</span>(<span class="number">1</span>,cn,cm)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h1 id="P4588-TJOI2018-数学计算"><a href="#P4588-TJOI2018-数学计算" class="headerlink" title="P4588 [TJOI2018]数学计算"></a>P4588 [TJOI2018]数学计算</h1><p>难在看出是用线段树（没区间没修改没线段……）</p><p>题目有两个操作，一个是乘一个值，另一个是除之前乘的某个值。转化一下，操作的目的为：改变一个值，查找之前的值。</p><p>可以将数据按时间排序，在时间轴上建线段树，维护区间乘。这样的话根节点就是到现在为止的所有数的乘积。<br>操作1：在对应时间点上乘上该数；<br>操作2：找到对应的时间点将该点值修改为1，然后pushup。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> llg;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">llg val;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T,Q,M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) tr[p]=&#123;l,r,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">tr[p]=&#123;l,r,<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,llg t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[p].l==tr[p].r)</span><br><span class="line">&#123;</span><br><span class="line">tr[p].val*=t;</span><br><span class="line">tr[p].val%=M;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(tr[p].l+tr[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>,l,mid,pos,t);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">mul</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,t);</span><br><span class="line">tr[p].val=tr[p&lt;&lt;<span class="number">1</span>].val*tr[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[p].l==tr[p].r)</span><br><span class="line">&#123;</span><br><span class="line">tr[p].val=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(tr[p].l+tr[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">divide</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">divide</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">tr[p].val=tr[p&lt;&lt;<span class="number">1</span>].val*tr[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));</span><br><span class="line">cin&gt;&gt;Q&gt;&gt;M;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,Q);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line">llg t,ans;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%ld&quot;</span>,&amp;op,&amp;t);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">mul</span>(<span class="number">1</span>,<span class="number">1</span>,Q,i,t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,tr[<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">divide</span>(<span class="number">1</span>,<span class="number">1</span>,Q,t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,tr[<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="P1502-窗口的星星"><a href="#P1502-窗口的星星" class="headerlink" title="P1502 窗口的星星"></a>P1502 窗口的星星</h1><p>典中典扫描线。</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll x,y1,y2;</span><br><span class="line">    ll dat;</span><br><span class="line">&#125;a[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">p</span>&#123;</span><br><span class="line">    ll l,r;</span><br><span class="line">    ll dat,add;</span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line">ll mp[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span>  <span class="comment">//将x坐标从小到大排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x) <span class="keyword">return</span> a.dat&lt;b.dat;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[p].l=l,t[p].r=r;</span><br><span class="line">    t[p].add=<span class="number">0</span>, t[p].dat=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p)</span>  <span class="comment">//表示p节点已经被修改，但子节点还没有被修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//修改子节点，并给子节点打延迟标记</span></span><br><span class="line">    t[p*<span class="number">2</span>].dat+=t[p].add;</span><br><span class="line">    t[p*<span class="number">2</span>+<span class="number">1</span>].dat+=t[p].add;</span><br><span class="line">    t[p*<span class="number">2</span>].add+=t[p].add;</span><br><span class="line">    t[p*<span class="number">2</span>+<span class="number">1</span>].add+=t[p].add;</span><br><span class="line">    t[p].add=<span class="number">0</span>;  <span class="comment">//清除p的标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线段树维护的内容是在区间1 ~ m内,区域(x, y) ~ (x + w, y + h)亮度的最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p, ll l, ll r, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;= t[p].l&amp;&amp; r&gt;= t[p].r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p].add+=x;</span><br><span class="line">        t[p].dat+=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add) <span class="built_in">spread</span>(p);<span class="comment">//延迟标记</span></span><br><span class="line">    <span class="type">int</span> mid =(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">    t[p].dat=<span class="built_in">max</span>(t[p*<span class="number">2</span>].dat,t[p*<span class="number">2</span>+<span class="number">1</span>].dat); <span class="comment">//更新节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line">ll n,w,h,x,y,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ld%ld%ld&quot;</span>,&amp;n,&amp;w,&amp;h);</span><br><span class="line">        ll num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%ld%ld%ld&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">            <span class="comment">//矩形边界上的星星不算，所以将矩形的上边界减1</span></span><br><span class="line">            a[++num]=&#123;x,y,y+h<span class="number">-1</span>,c&#125;;    </span><br><span class="line">            mp[num]=y;</span><br><span class="line">            a[++num]=&#123;x+w,y,y+h<span class="number">-1</span>,-c&#125;;</span><br><span class="line">            mp[num]=y+h<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(mp+<span class="number">1</span>,mp+<span class="number">1</span>+num);</span><br><span class="line">        <span class="type">int</span> m=<span class="built_in">unique</span>(mp+<span class="number">1</span>,mp+<span class="number">1</span>+num)-mp<span class="number">-1</span>; <span class="comment">//离散化 + 去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">        &#123;  <span class="comment">//预处理出所有坐标离散化之后的结果</span></span><br><span class="line">            a[i].y1=<span class="built_in">lower_bound</span>(mp+<span class="number">1</span>,mp+<span class="number">1</span>+m,a[i].y1)-mp;</span><br><span class="line">            a[i].y2=<span class="built_in">lower_bound</span>(mp+<span class="number">1</span>,mp+<span class="number">1</span>+m,a[i].y2)-mp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+num,cmp);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);  <span class="comment">//建树</span></span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,a[i].y1,a[i].y2,a[i].dat);  </span><br><span class="line">            ans=<span class="built_in">max</span>(ans,t[<span class="number">1</span>].dat);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="P2471-SCOI2007-降雨量"><a href="#P2471-SCOI2007-降雨量" class="headerlink" title="P2471 [SCOI2007] 降雨量"></a>P2471 [SCOI2007] 降雨量</h1><p>小细节最多的一道题，调得我失去智商。<br>不离散化80pts（两个点RE）。</p><ol><li>x&gt;=y无解，出false</li><li>y和x均未知，maybe</li><li>包括y和x的整个区间都已知，按题意判断true或false</li><li>y和x均已知但中间有未知的，按题意判断maybe或false</li><li>有一个未知，判断另一个与区间的大小关系maybe或false</li></ol><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> val;<span class="comment">//降雨量</span></span><br><span class="line"><span class="type">bool</span> known;<span class="comment">//是否已知</span></span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> m,n,cnt,a[N],first,now,mem[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[l]==<span class="number">-1</span>)</span><br><span class="line">tr[p]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">else</span> tr[p]=&#123;l,r,a[l],<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">tr[p].l=l,tr[p].r=r;</span><br><span class="line">tr[p].val=<span class="built_in">max</span>(tr[p&lt;&lt;<span class="number">1</span>].val,tr[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val);</span><br><span class="line">tr[p].known=(tr[p&lt;&lt;<span class="number">1</span>].known&amp;&amp;tr[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].known)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tr[p].l&amp;&amp;tr[p].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;tr[p].l:&quot;&lt;&lt;tr[p].l&lt;&lt;&quot; tr[p].r:&quot;&lt;&lt;tr[p].r&lt;&lt;&quot; tr[p].val:&quot;&lt;&lt;tr[p].val&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> tr[p].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(tr[p].l+tr[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) maxn=<span class="built_in">max</span>(<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,l,r),maxn);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) maxn=<span class="built_in">max</span>(<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r),maxn);</span><br><span class="line"><span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tr[p].l&amp;&amp;tr[p].r&lt;=r)</span><br><span class="line"><span class="keyword">return</span> tr[p].known;</span><br><span class="line"><span class="type">int</span> mid=(tr[p].l+tr[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) flag=<span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) flag=<span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r)?flag:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">cin&gt;&gt;first&gt;&gt;a[++cnt];</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">-1</span>,mp[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//在最前面插入一个点（前面所有的未知年份压缩成一个）</span></span><br><span class="line">now=first,mem[<span class="number">1</span>]=first,mp[first]=cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> year,rain;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;year,&amp;rain);</span><br><span class="line"><span class="keyword">if</span>(year<span class="number">-1</span>!=now)<span class="comment">//中间不连续</span></span><br><span class="line">&#123;</span><br><span class="line">a[++cnt]=<span class="number">-1</span>,now++;</span><br><span class="line">mem[cnt]=now,mp[now]=cnt;<span class="comment">//插入一个未知点（如果有很多未知的年份也压缩成一个）</span></span><br><span class="line">&#125;</span><br><span class="line">a[++cnt]=rain,now=year,mem[cnt]=now,mp[now]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">a[++cnt]=<span class="number">-1</span>,now++;</span><br><span class="line">mem[cnt]=now,mp[now]=cnt;<span class="comment">//在最后面插入一个点（后面所有的未知年份压缩成一个）</span></span><br><span class="line"><span class="comment">/*for(int i=1;i&lt;=cnt;i++)</span></span><br><span class="line"><span class="comment">cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=cnt;i++)</span></span><br><span class="line"><span class="comment">cout&lt;&lt;mem[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;*/</span></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y,ok=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(y&lt;=x)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> xx=<span class="built_in">upper_bound</span>(mem+<span class="number">1</span>,mem+cnt+<span class="number">1</span>,x)-mem<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> yy=<span class="built_in">upper_bound</span>(mem+<span class="number">1</span>,mem+cnt+<span class="number">1</span>,y)-mem<span class="number">-1</span>;</span><br><span class="line">x=x&lt;first?<span class="number">0</span>:mp[mem[xx]];</span><br><span class="line">y=mp[mem[yy]];</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;x:&quot;&lt;&lt;x&lt;&lt;&quot; a[x]:&quot;&lt;&lt;a[x]&lt;&lt;&quot; y:&quot;&lt;&lt;y&lt;&lt;&quot; a[y]:&quot;&lt;&lt;a[y]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(a[x]==<span class="number">-1</span>&amp;&amp;a[y]==<span class="number">-1</span>)<span class="comment">//均未知</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;maybe&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[x]&gt;<span class="number">0</span>&amp;&amp;a[y]&gt;<span class="number">0</span>&amp;&amp;a[x]&lt;a[y])<span class="comment">//均已知</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y-x&lt;<span class="number">1</span>)<span class="comment">//特判的情况</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[x]==<span class="number">-1</span>||a[y]==<span class="number">-1</span>)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;maybe&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[x]&lt;a[y])</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;true&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxi=<span class="built_in">query</span>(<span class="number">1</span>,x+<span class="number">1</span>,y<span class="number">-1</span>);<span class="comment">//找到中间点的最大降水量</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;maxi:&quot;&lt;&lt;maxi&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(a[x]&gt;<span class="number">0</span>&amp;&amp;a[y]&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(maxi&gt;=a[y])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> ok=<span class="built_in">ask</span>(<span class="number">1</span>,x+<span class="number">1</span>,y<span class="number">-1</span>);<span class="comment">//看看中间是否有未知的</span></span><br><span class="line"><span class="keyword">if</span>(ok) cout&lt;&lt;<span class="string">&quot;true&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;maybe&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//一个已知，一个未知</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[x]&gt;<span class="number">0</span>&amp;&amp;maxi&gt;=a[x])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[y]&gt;<span class="number">0</span>&amp;&amp;maxi&gt;=a[y])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;maybe&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h1 id="P4198-楼房重建"><a href="#P4198-楼房重建" class="headerlink" title="P4198 楼房重建"></a>P4198 楼房重建</h1><p>转化成斜率单调递增序列问题。</p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区间最大可修改上升</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> slope;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"><span class="comment">//slope维护区间内最大的斜率</span></span><br><span class="line"><span class="comment">//num维护区间内递增斜率序列的长度</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">double</span> maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tr[p].slope&lt;=maxn) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不符合条件 </span></span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[p].slope&gt;maxn;<span class="comment">//递归到叶结点，判断该点斜率是否大于maxn </span></span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[p&lt;&lt;<span class="number">1</span>].slope&lt;=maxn)<span class="comment">//左子树中的所有点都会被挡住 </span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,maxn);<span class="comment">//找右子树中未被挡住的点 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,l,mid,maxn)+tr[p].num-tr[p&lt;&lt;<span class="number">1</span>].num;</span><br><span class="line"><span class="comment">//右子树中所有点都未被挡住，找左子树中未被挡住的点 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">tr[p]=&#123;<span class="number">1.0</span>*y/x,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">tr[p].slope=<span class="built_in">max</span>(tr[p&lt;&lt;<span class="number">1</span>].slope,tr[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].slope);</span><br><span class="line">tr[p].num=tr[p&lt;&lt;<span class="number">1</span>].num+<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tr[p&lt;&lt;<span class="number">1</span>].slope);</span><br><span class="line"><span class="comment">//左子树递增斜率序列的长度+右子树中递增斜率序列的长度（右子树中算数的斜率应都大于 tr[p&lt;&lt;1].slope） </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h1 id="P2574-XOR的艺术"><a href="#P2574-XOR的艺术" class="headerlink" title="P2574 XOR的艺术"></a>P2574 XOR的艺术</h1><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200020</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r,num,mark;</span><br><span class="line">&#125;t[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p].l=l,t[p].r=r;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].num=a[l];</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;p:&quot;&lt;&lt;p&lt;&lt;&#x27; &#x27;&lt;&lt;a[l]&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line"><span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[p].num=t[p*<span class="number">2</span>].num+t[p*<span class="number">2</span>+<span class="number">1</span>].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].mark)</span><br><span class="line">&#123;</span><br><span class="line">t[p*<span class="number">2</span>].num=(t[p*<span class="number">2</span>].r-t[p*<span class="number">2</span>].l+<span class="number">1</span>)-t[p*<span class="number">2</span>].num;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].num=(t[p*<span class="number">2</span>+<span class="number">1</span>].r-t[p*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)-t[p*<span class="number">2</span>+<span class="number">1</span>].num;</span><br><span class="line">t[p*<span class="number">2</span>].mark^=<span class="number">1</span>;</span><br><span class="line">t[p*<span class="number">2</span>+<span class="number">1</span>].mark^=<span class="number">1</span>;</span><br><span class="line">t[p].mark=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">t[p].num=(t[p].r-t[p].l+<span class="number">1</span>)-t[p].num;</span><br><span class="line">t[p].mark^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">spread</span>(p);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">change</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">t[p].num=t[p*<span class="number">2</span>].num+t[p*<span class="number">2</span>+<span class="number">1</span>].num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].l&gt;=l&amp;&amp;t[p].r&lt;=r) </span><br><span class="line"><span class="keyword">return</span> t[p].num;<span class="comment">//如果完全包含，返回区间</span></span><br><span class="line"><span class="type">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">spread</span>(p);<span class="comment">//下传标记</span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);<span class="comment">//继续向下</span></span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>) cout&lt;&lt;<span class="built_in">ask</span>(<span class="number">1</span>,l,r)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">0</span>) <span class="built_in">change</span>(<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h1 id="P3374-【模板】树状数组-1"><a href="#P3374-【模板】树状数组-1" class="headerlink" title="P3374 【模板】树状数组 1"></a>P3374 【模板】树状数组 1</h1><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> j,<span class="type">int</span> n,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=j;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">&#123;</span><br><span class="line">c[i]+=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=add;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">&#123;</span><br><span class="line">ans+=c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,q,i;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">update</span>(i,n,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j,x;</span><br><span class="line">cin&gt;&gt;j&gt;&gt;x;</span><br><span class="line"><span class="built_in">update</span>(j,n,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line">sum=<span class="built_in">getsum</span>(r)-<span class="built_in">getsum</span>(l<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;L&quot;&lt;&lt;getsum(l-1)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;R&quot;&lt;&lt;getsum(r)&lt;&lt;endl;</span></span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="P3368-【模板】树状数组-2"><a href="#P3368-【模板】树状数组-2" class="headerlink" title="P3368 【模板】树状数组 2"></a>P3368 【模板】树状数组 2</h1><h2 id="-7"><a href="#-7" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">500005</span>],dif[<span class="number">500005</span>],c[<span class="number">500005</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">long</span> <span class="type">long</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]+=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">sum+=c[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> option;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;option);</span><br><span class="line"><span class="keyword">if</span>(option==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> front,tail;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;front,&amp;tail,&amp;z);</span><br><span class="line"><span class="built_in">update</span>(front,z);</span><br><span class="line"><span class="built_in">update</span>(tail+<span class="number">1</span>,-z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(option==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">cout&lt;&lt;<span class="built_in">get_sum</span>(q)+a[q]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="P1908-逆序对"><a href="#P1908-逆序对" class="headerlink" title="P1908 逆序对"></a>P1908 逆序对</h1><p>树状数组也能写，这里就贴古早学习的归并排序了。</p><h2 id="-8"><a href="#-8" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp[<span class="number">500005</span>],a[<span class="number">500005</span>],n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">merge</span>(l,mid);</span><br><span class="line"><span class="built_in">merge</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="type">int</span> i=l,j=mid+<span class="number">1</span>,p=l;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">temp[p++]=a[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans+=(mid-i+<span class="number">1</span>),</span><br><span class="line">temp[p++]=a[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">temp[p++]=a[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">temp[p++]=a[j++];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)</span><br><span class="line">a[k]=temp[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">merge</span>(<span class="number">1</span>,n);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="P1966-NOIP2013-提高组-火柴排队"><a href="#P1966-NOIP2013-提高组-火柴排队" class="headerlink" title="P1966 [NOIP2013 提高组] 火柴排队"></a>P1966 [NOIP2013 提高组] 火柴排队</h1><p>离散化+求逆序对数</p><h2 id="-9"><a href="#-9" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e8</span><span class="number">-3</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],d[N],e[N],pos[N],n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">ret+=c[i];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i]),a[i]=d[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e[i]),b[i]=e[i];</span><br><span class="line"><span class="built_in">sort</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sort</span>(e+<span class="number">1</span>,e+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=<span class="built_in">lower_bound</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,a[i])-d;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;a[i]:&quot;&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">pos[a[i]]=i;</span><br><span class="line">b[i]=<span class="built_in">lower_bound</span>(e+<span class="number">1</span>,e+n+<span class="number">1</span>,b[i])-e;</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;pos[&quot;&lt;&lt;a[i]&lt;&lt;&quot;]=&quot;&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;b[i]&quot;&lt;&lt;b[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">b[i]=pos[b[i]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=<span class="built_in">ask</span>(n)-<span class="built_in">ask</span>(b[i]);</span><br><span class="line"><span class="comment">//cout&lt;&lt;&quot;ans:&quot;&lt;&lt;ans&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">ans%=mod;</span><br><span class="line"><span class="built_in">add</span>(b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">memset(c,0,sizeof(c));</span></span><br><span class="line"><span class="comment">for(int i=n;i;i--)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ans+=ask(b[i]);</span></span><br><span class="line"><span class="comment">cout&lt;&lt;&quot;ans:&quot;&lt;&lt;ans&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line"><span class="comment">ans%=mod;</span></span><br><span class="line"><span class="comment">add(b[i]);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h1 id="P5677-GZOI2017-配对统计"><a href="#P5677-GZOI2017-配对统计" class="headerlink" title="P5677 [GZOI2017]配对统计"></a>P5677 [GZOI2017]配对统计</h1><p>一个数能与它形成好配对的一定是和它差值最小的数。顺着这个思路我们可以考虑将数列排序，排序后对于一个数字能与其匹配的只有它左边或右边的数，对于 1 和 n 的情况进行特判，如果两边差值相等就都是好配对。<br>现在问题就转化为给定一些配对找在$[l,r]$这段区间中有几个好配对，对于这个问题，由于题目并未强制在线，我们可以考虑将询问离线保存，重新排序（按右端点大小）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> llg long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,l,r,total,cnt;</span><br><span class="line"><span class="type">int</span> c[N],pre[N],mem[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val,pos;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pa</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">&#125;p[N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Node x,Node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(pa x,pa y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">section</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">&#125;sec[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(section x,section y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">ret+=c[i];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=pos;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">c[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_pair</span><span class="params">(Node x,Node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p[++cnt].l=<span class="built_in">min</span>(x.pos,y.pos);</span><br><span class="line">p[cnt].r=<span class="built_in">max</span>(x.pos,y.pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].val=<span class="built_in">read</span>();</span><br><span class="line">a[i].pos=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_pair</span>(a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">add_pair</span>(a[n<span class="number">-1</span>],a[n]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t1=a[i].val-a[i<span class="number">-1</span>].val;</span><br><span class="line"><span class="type">int</span> t2=a[i+<span class="number">1</span>].val-a[i].val;</span><br><span class="line"><span class="keyword">if</span>(t1&lt;t2) <span class="built_in">add_pair</span>(a[i<span class="number">-1</span>],a[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t2==t1) <span class="built_in">add_pair</span>(a[i<span class="number">-1</span>],a[i]),<span class="built_in">add_pair</span>(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add_pair</span>(a[i],a[i+<span class="number">1</span>]);;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(p+<span class="number">1</span>,p+cnt+<span class="number">1</span>,cmp2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">sec[i].l=<span class="built_in">read</span>(),sec[i].r=<span class="built_in">read</span>();</span><br><span class="line">sec[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(sec+<span class="number">1</span>,sec+m+<span class="number">1</span>,cmp);<span class="comment">//按右端点从小到大排序 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=m ; i++)</span><br><span class="line">&#123;<span class="comment">//i为当前询问，j为当前待入树状数组的好对 </span></span><br><span class="line"><span class="keyword">while</span>(p[j].r&lt;=sec[i].r&amp;&amp;j&lt;=cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">add</span>(p[j].l);<span class="comment">//如果当前好对的右端点在当前询问的右端点内，就加入树状数组 </span></span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">ans+=<span class="number">1ll</span>*sec[i].id*(j<span class="number">-1</span>-<span class="built_in">get</span>(sec[i].l<span class="number">-1</span>));<span class="comment">//计算答案 </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Soduku</title>
      <link href="/2022/08/17/Soduku/"/>
      <url>/2022/08/17/Soduku/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2ee1b498d9fa42c68ec46368ebabfd81.jpeg" alt="在这里插入图片描述"></p><p><a href="https://www.acwing.com/problem/content/168/">166. 数独</a></p><p>显然要用到DFS，对于每个未填的空格，要排除掉同行同列同九宫内出现过的数字。不加优化不出意外的话会T飞︿(￣︶￣)︿。</p><p>考虑剪枝：</p><ol><li>优化搜索顺序</li><li>排除冗余信息</li><li>可行性剪枝（照当前分支这样走后面不可能达成）</li><li>最优性剪枝（照当前分支这样走的最优解都比当前解差）</li><li>记忆化搜索</li></ol><p>这里我们主要考虑优化搜索顺序。这其实是跟大家做数独的时候的朴素感知是一样的，从可选的数少的空格开始试探。所以我们在每次搜索时都判断一下哪个格子的可选到数最小（可以预先处理出来可能会用到的所有二进制数里1的个数，用时直接调用）。</p><p>记录每个格子可选的数，可以用二进制状态压缩，开九位表示九个数。为了方便，我们把1~9映射成0 ~8。开三个数组$row[N],col[N],cell[N/3][N/3]$分别记录每行、每列、每个九宫格内有哪些数不能填。对于位置在$(x,y)$的数，用 row[x] &amp; col[y] &amp; cell[x/3][y/3] 可以查到该空格可以填哪些数，那就老老实实搜索这些数吧233，可以用lowbit获得二进制下为1的每一位，将其转化成十进制数（1的位置对应的位数，可以预先处理出来）。搜索到每一个数时改变一下row.col.cell的状态，回溯的时候复原。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">9</span>;</span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> mp[<span class="number">1</span>&lt;&lt;N],nums[<span class="number">1</span>&lt;&lt;N],row[N],col[N],cell[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> row[x]&amp;col[y]&amp;cell[x/<span class="number">3</span>][y/<span class="number">3</span>];<span class="comment">//求出这一个位置可能会被填哪些数字 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化：所有位所有数字都可以填 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) </span><br><span class="line">row[i]=col[i]=(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">cell[i][j]=(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//所有待填数字都已经被填上 </span></span><br><span class="line"><span class="type">int</span> minn=<span class="number">10</span>,x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i*<span class="number">9</span>+j]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp=nums[<span class="built_in">get</span>(i,j)];</span><br><span class="line"><span class="keyword">if</span>(temp&lt;minn)</span><br><span class="line">&#123;</span><br><span class="line">minn=temp;</span><br><span class="line">x=i,y=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//找到所有剩下的待填格中数字集合最小的一个，是一个剪枝过程 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">get</span>(x,y);i;i-=<span class="built_in">lowbit</span>(i))<span class="comment">//枚举这一格所有可能填的数字 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=mp[<span class="built_in">lowbit</span>(i)];</span><br><span class="line">row[x]-=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">col[y]-=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">cell[x/<span class="number">3</span>][y/<span class="number">3</span>]-=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">str[x*<span class="number">9</span>+y]=<span class="string">&#x27;1&#x27;</span>+t;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(cnt<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">row[x]+=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">col[y]+=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">cell[x/<span class="number">3</span>][y/<span class="number">3</span>]+=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">str[x*<span class="number">9</span>+y]=<span class="string">&#x27;.&#x27;</span>;<span class="comment">//复原 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) mp[<span class="number">1</span>&lt;&lt;i]=i;<span class="comment">//预先存下二进制1所在的位置 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;N);i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j;j-=<span class="built_in">lowbit</span>(j)) nums[i]++;</span><br><span class="line"><span class="comment">//预先存下每个之后可能会枚举到的二进制数内有几个1 </span></span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;str&amp;&amp;str[<span class="number">0</span>]!=<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,k=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++,k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[k]!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=str[k]-<span class="string">&#x27;1&#x27;</span>;<span class="comment">//1~9映射到0~8 </span></span><br><span class="line">row[i]-=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">col[j]-=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">cell[i/<span class="number">3</span>][j/<span class="number">3</span>]-=(<span class="number">1</span>&lt;&lt;t);</span><br><span class="line">&#125;<span class="comment">//这一位数字是题给的，把它存进对应位置 </span></span><br><span class="line"><span class="keyword">else</span> cnt++;<span class="comment">//待填数字+1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(cnt);</span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> DFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<div class='poem'><div class='poem-title'>浮生六记</div><div class='poem-author'>沈复</div><p>闲来静处，且将诗酒放狂， 唱一曲归来未晚，歌一调湖海茫茫。逢时遇景，拾翠寻芳。 约几个知心密友，到野外溪旁，或琴棋适性，或曲水流觞； 或说些善因果报，或论些今古兴亡；看花枝堆锦绣，听鸟语弄笙簧。 一任他人情反复，世态炎凉，优游闲岁月，潇洒度时光。</p></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Me：</p><p>name: Ember0520</p><p>link: <a href="https://ember0520.github.io/">https://ember0520.github.io/</a></p><p>avatar: <a href="https://img.gejiba.com/images/0f75a56c15ded7cf02ecfb79ea5fa00d.jpg">https://img.gejiba.com/images/0f75a56c15ded7cf02ecfb79ea5fa00d.jpg</a></p></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
